////////////////////////////////////////////////////////////////////////////////
// SoftKinetic DepthSense SDK
//
// COPYRIGHT AND CONFIDENTIALITY NOTICE - SOFTKINETIC CONFIDENTIAL
// INFORMATION
//
// All rights reserved to SOFTKINETIC SENSORS NV (a
// company incorporated and existing under the laws of Belgium, with
// its principal place of business at Boulevard de la Plainelaan 11,
// 1050 Brussels (Belgium), registered with the Crossroads bank for
// enterprises under company number 0811 341 454 - "Softkinetic
// Sensors").
//
// The source code of the SoftKinetic DepthSense Camera Drivers is
// proprietary and confidential information of Softkinetic Sensors NV.
//
// For any question about terms and conditions, please contact:
// info@softkinetic.com Copyright (c) 2002-2015 Softkinetic Sensors NV
////////////////////////////////////////////////////////////////////////////////

// automatically generated by dsic, do not edit
#ifndef _DEPTHSENSE_PUBLIC_HXX
#define _DEPTHSENSE_PUBLIC_HXX
/// The DepthSense Software Development Kit
namespace DepthSense
{
    class Interface;
    class AudioNode;
    class ColorNode;
    class BaseValue;
    class GPIOValue;
    class FloatParameterValue;
    class BoolParameterValue;
    class IntParameterValue;
    class RegionOfInterestValue;
    class I2CArrayValue;
    class RegisterValue;
    class SystemInfoValue;
    class SystemCalibrationValue;
    class TemperatureCorrection;
    class CyclicErrorCorrection;
    class GradientDistortionCorrection;
    class Calibration;
    class HardwareVersion;
    class SystemStateValue;
    class DepthNode;
    class UnsupportedNode;
    class Context;
    class Device;
    class Node;
    namespace Audio
    {
        class SampleData;
    };
    namespace Color
    {
        class SampleData;
    };
    namespace Depth
    {
        class IMUData;
        class SampleData;
        class ButtonEventData;
        class SampleDataEx;
    };
};
#include <vector>
#include <string>
#include <functional>
#include <DepthSenseAPI.h>
#include <Pointer.hxx>
#include <String.hxx>
#include <Vector.hxx>
#include <Type.hxx>
#include <Event.hxx>
namespace DSI
{
    class Client;
    class Marshalling;
    class CMarshalling;
}
namespace DepthSense
{
    namespace Utils
    {
        class BinaryReader;
    }
}
namespace DepthSense
{
    /// The Raw Output Mode of the device
    ///
    /// A type enumerating the various raw output mode supported by DepthSense SDK
    enum RawOutputMode
    {
        RAW_OUTPUT_MODE_UNKNOWN = 0,/*!< Unknown */
        RAW_OUTPUT_MODE_REGULAR = 1,/*!< The default raw output mode */
        RAW_OUTPUT_MODE_QUAD_MODE_AB = 2,/*!< Quad mode A-B */
        RAW_OUTPUT_MODE_QUAD_MODE_A = 3,/*!< Quad mode A */
        RAW_OUTPUT_MODE_QUAD_MODE_B = 4,/*!< Quad mode B */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String RawOutputMode_toString_p (RawOutputMode value);
    #endif
    /// Converts a DepthSense::RawOutputMode value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::RawOutputMode, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string RawOutputMode_toString (RawOutputMode value)
    {
        return RawOutputMode_toString_p(value).unmarshal();
    }
    /// The unit in which a parameter is expressed in
    ///
    /// A type enumerating the various units supported by DepthSense SDK
    enum UnitType
    {
        UNIT_TYPE_UNKNOWN = 0,/*!< Unknown */
        UNIT_TYPE_NONE = 1,/*!< No unit */
        UNIT_TYPE_MILLISECONDS = 2,/*!< Milliseconds */
        UNIT_TYPE_MHZ = 3,/*!< MHertz */
        UNIT_TYPE_VOLTS = 4,/*!< Volts */
        UNIT_TYPE_METERS = 5,/*!< Meters */
        UNIT_TYPE_PERCENT = 6,/*!< Percent */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String UnitType_toString_p (UnitType value);
    #endif
    /// Converts a DepthSense::UnitType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::UnitType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string UnitType_toString (UnitType value)
    {
        return UnitType_toString_p(value).unmarshal();
    }
    enum IlluminationMode
    {
        ILLUMINATION_MODE_UNKNOWN = -1,
        ILLUMINATION_MODE_AC = 0,
        ILLUMINATION_MODE_OFF = 1,
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String IlluminationMode_toString_p (IlluminationMode value);
    #endif
    /// Converts a DepthSense::IlluminationMode value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::IlluminationMode, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string IlluminationMode_toString (IlluminationMode value)
    {
        return IlluminationMode_toString_p(value).unmarshal();
    }
    enum MixMode
    {
        MIX_MODE_UNKNOWN = -1,
        MIX_MODE_MOD = 0,
        MIX_MODE_OFF = 1,
        MIX_MODE_A = 2,
        MIX_MODE_B = 3,
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String MixMode_toString_p (MixMode value);
    #endif
    /// Converts a DepthSense::MixMode value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::MixMode, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string MixMode_toString (MixMode value)
    {
        return MixMode_toString_p(value).unmarshal();
    }
    enum AccessMode
    {
        ACCESS_MODE_UNKNOWN = 0,
        ACCESS_MODE_RW = 1,
        ACCESS_MODE_RO = 2,
        ACCESS_MODE_WO = 3,
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String AccessMode_toString_p (AccessMode value);
    #endif
    /// Converts a DepthSense::AccessMode value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::AccessMode, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string AccessMode_toString (AccessMode value)
    {
        return AccessMode_toString_p(value).unmarshal();
    }
    /// The alias to a system parameters
    ///
    /// A type enumerating the various system parameters supported by DepthSense SDK
    enum ParameterType
    {
        PARAMETER_TYPE_UNKNOWN = -1,/*!< Unknown */
        PARAMETER_TYPE_LEFT_ILLUMINATION_VOLTAGE = 0,/*!< The left illumination voltage */
        PARAMETER_TYPE_RIGHT_ILLUMINATION_VOLTAGE = 1,/*!< The right illumination voltage */
        PARAMETER_TYPE_MIXING_VOLTAGE = 2,/*!< The mixing voltage */
        PARAMETER_TYPE_FRAME_RATE = 3,/*!< The frame rate */
        PARAMETER_TYPE_MICRO_FRAME_NUMBER = 4,/*!< The number of micro frames */
        PARAMETER_TYPE_INTEGRATION_TIME = 5,/*!< The integration time */
        PARAMETER_TYPE_MODULATION_FREQUENCY = 6,/*!< The modulation frequency */
        PARAMETER_TYPE_DEALIASING_ON = 7,/*!< Whether dealiasing is enabled or not */
        PARAMETER_TYPE_DEALIASING_FREQUENCY = 8,/*!< The dealising frequency */
        PARAMETER_TYPE_MIXING_SIGNALS_MODE = 9,/*!< The mixing signals */
        PARAMETER_TYPE_ILLUMINATION_MODE = 10,/*!< The illumination */
        PARAMETER_TYPE_RAW_OUTPUT_MODE = 11,/*!< Raw Output Mode */
        PARAMETER_TYPE_RANGE = 12,/*!< The range of the camera */
        PARAMETER_TYPE_REGION_OF_INTEREST = 13,/*!< The region of interest */
        PARAMETER_TYPE_STREAM_ENABLE = 14,/*!< Whether to enable or disable the streaming */
        PARAMETER_TYPE_NATIVE_FRAME_FORMAT = 15,/*!< The native Frame Format of the device */
        PARAMETER_TYPE_CAMERA_MODE = 16,/*!< The camera mode */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String ParameterType_toString_p (ParameterType value);
    #endif
    /// Converts a DepthSense::ParameterType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::ParameterType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string ParameterType_toString (ParameterType value)
    {
        return ParameterType_toString_p(value).unmarshal();
    }
    /// The module type
    ///
    /// A type enumerating the various module types supported by DepthSense SDK
    enum ModuleType
    {
        MODULE_TYPE_UNKNOWN = 0,/*!< Unknown */
        MODULE_TYPE_MAIN = 1,/*!< TI-CDK Gen1 Main board */
        MODULE_TYPE_CONTROLLER = 2,/*!< TI-CDK Gen1 Controller board */
        MODULE_TYPE_SENSOR = 3,/*!< TI-CDK Gen1 Sensor board */
        MODULE_TYPE_LED = 4,/*!< TI-CDK Gen1 LED board */
        MODULE_TYPE_LASER = 5,/*!< Laser board - not used */
        MODULE_TYPE_TICDK_GEN2_CONTROLLER = 258,/*!< TI-CDK Gen2 Controller board */
        MODULE_TYPE_TICDK_GEN2_SENSOR = 259,/*!< TI-CDK Gen2 Sensor board */
        MODULE_TYPE_TICDK_GEN2_LED = 260,/*!< TI-CDK Gen2 LED board */
        MODULE_TYPE_TICDK_GEN2_LED_LEFT = 263,/*!< TI-CDK Gen2 LED board left */
        MODULE_TYPE_TICDK_GEN2_LED_RIGHT = 264,/*!< TI-CDK Gen2 LED board right */
        MODULE_TYPE_DIVA_GEN1_MAIN = 65281,/*!< SK-DiVA Gen 1 Main board - 0xFF01 */
        MODULE_TYPE_DIVA_GEN1_CONTROLLER = 65282,/*!< SK-DiVA Gen 1 Controller board - 0xFF02 */
        MODULE_TYPE_DIVA_GEN1_SUN_ILLUMINATION = 65286,/*!< SK-DiVA Gen 1 Sun Illumination board - 0xFF06 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_MLX75023_OPTOPAC = 65312,/*!< SK-DiVA Gen 1 Sensor MLX75023/Optopac board - 0xFF20 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_4TAP_HDR_QFN88 = 65313,/*!< SK-DiVA Gen 1 Sensor 4Tap HDR/QFN88 board - 0xFF21 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_DGH_P0_QFN32 = 65314,/*!< SK-DiVA Gen 1 Sensor DGH-P0/QFN32 board - 0xFF22 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_QQQVGA_2T_ARST_QFP44 = 65315,/*!< SK-DiVA Gen 1 Sensor QQQVGA-2T Active reset/QFP44 board - 0xFF23 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_QVGAD_SYM_SHUT_QFN88 = 65316,/*!< SK-DiVA Gen 1 Sensor QVGA-D Symmetric/Shutter version/QFN88 board - 0xFF24 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_QVGAA_HDR_QFP44 = 65317,/*!< SK-DiVA Gen 1 Sensor QVGA-A HDR/QFP44 board - 0xFF25 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_QVGA_QFN = 65318,/*!< SK-DiVA Gen 1 Sensor QVGA-D QFN - 0xFF26 */
        MODULE_TYPE_DIVA_GEN1_SENSOR_QVGA_SOCKET = 65319,/*!< SK-DiVA Gen 1 Sensor QVGA-D Socket - 0xFF27 */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String ModuleType_toString_p (ModuleType value);
    #endif
    /// Converts a DepthSense::ModuleType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::ModuleType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string ModuleType_toString (ModuleType value)
    {
        return ModuleType_toString_p(value).unmarshal();
    }
    /// The type of a BaseValue
    enum BaseValueType
    {
        BASE_VALUE_TYPE_UNKNOWN = 0,/*!< Unknown */
        BASE_VALUE_TYPE_GPIO = 1,/*!< The Gpio type */
        BASE_VALUE_TYPE_FLOAT_PARAMETER = 2,/*!< The float parameter type */
        BASE_VALUE_TYPE_INT_PARAMETER = 3,/*!< The int parameter type */
        BASE_VALUE_TYPE_BOOL_PARAMETER = 4,/*!< The bool parameter type */
        BASE_VALUE_TYPE_REGION_OF_INTEREST = 5,/*!< The RegionOfInterest type */
        BASE_VALUE_TYPE_I2CREGISTER = 6,/*!< The Register type */
        BASE_VALUE_TYPE_HARDWARE_VERSION = 7,/*!< The hardware version */
        BASE_VALUE_TYPE_SYSTEM_CALIBRATION = 8,/*!< The System Calibration type */
        BASE_VALUE_TYPE_SYSTEM_STATE = 9,/*!< The System State type */
        BASE_VALUE_TYPE_I2CARRAY = 10,/*!< The I2CArray type */
        BASE_VALUE_TYPE_SYSTEM_INFO = 11,/*!< The System Info type */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String BaseValueType_toString_p (BaseValueType value);
    #endif
    /// Converts a DepthSense::BaseValueType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::BaseValueType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string BaseValueType_toString (BaseValueType value)
    {
        return BaseValueType_toString_p(value).unmarshal();
    }
    /// The algorithm to be used to perform the temperature correction
    enum TemperatureCorrectionAlgorithm
    {
        TEMPERATURE_CORRECTION_ALGORITHM_NONE = 0,/*!< None */
        TEMPERATURE_CORRECTION_ALGORITHM_ONE_FACTOR = 1,/*!< One factor */
        TEMPERATURE_CORRECTION_ALGORITHM_TWO_FACTORS = 2,/*!< Two factors */
        TEMPERATURE_CORRECTION_ALGORITHM_GENERIC_LINEAR_COMBINATION = 3,/*!< Generic Linear Combination */
        TEMPERATURE_CORRECTION_ALGORITHM_LINEAR_WITH_TEMPERATURE_SMOOTHING = 4,/*!< Linear Combination with temperature smoothing */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String TemperatureCorrectionAlgorithm_toString_p (TemperatureCorrectionAlgorithm value);
    #endif
    /// Converts a DepthSense::TemperatureCorrectionAlgorithm value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::TemperatureCorrectionAlgorithm, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string TemperatureCorrectionAlgorithm_toString (TemperatureCorrectionAlgorithm value)
    {
        return TemperatureCorrectionAlgorithm_toString_p(value).unmarshal();
    }
    /// The algorithm to be used to perform the cyclic error correction
    enum CyclicErrorCorrectionAlgorithm
    {
        CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE = 0,/*!< None */
        CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4 = 1,/*!< A * Cos( 2 * Phi ) + B * Sin( 2 * Phi) + C * Cos( 4 * Phi ) + D * Sin( 4 * Phi ) */
        CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL = 2,/*!< Indirect 12 harmonics model */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CyclicErrorCorrectionAlgorithm_toString_p (CyclicErrorCorrectionAlgorithm value);
    #endif
    /// Converts a DepthSense::CyclicErrorCorrectionAlgorithm value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CyclicErrorCorrectionAlgorithm, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CyclicErrorCorrectionAlgorithm_toString (CyclicErrorCorrectionAlgorithm value)
    {
        return CyclicErrorCorrectionAlgorithm_toString_p(value).unmarshal();
    }
    /// The algorithm to be used to perform the gradient distortion correction
    enum GradientDistortionCorrectionAlgorithm
    {
        GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE = 0,/*!< None */
        GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55 = 1,/*!< Poly 5-5 */
        GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS = 2,/*!< Poly 5-5 tuple for even and odd columns */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String GradientDistortionCorrectionAlgorithm_toString_p (GradientDistortionCorrectionAlgorithm value);
    #endif
    /// Converts a DepthSense::GradientDistortionCorrectionAlgorithm value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::GradientDistortionCorrectionAlgorithm, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string GradientDistortionCorrectionAlgorithm_toString (GradientDistortionCorrectionAlgorithm value)
    {
        return GradientDistortionCorrectionAlgorithm_toString_p(value).unmarshal();
    }
    /// The image resolution
    ///   
    /// A type enumerating the various frame formats supported by
    /// DepthSense SDK.
    enum FrameFormat
    {
        FRAME_FORMAT_UNKNOWN = 0,/*!< unknown */
        FRAME_FORMAT_QQVGA = 1,/*!< QQVGA (160x120) */
        FRAME_FORMAT_QCIF = 2,/*!< QCIF (176x144) */
        FRAME_FORMAT_HQVGA = 3,/*!< HQVGA (240x160) */
        FRAME_FORMAT_QVGA = 4,/*!< QVGA (320x240) */
        FRAME_FORMAT_CIF = 5,/*!< CIF (352x288) */
        FRAME_FORMAT_HVGA = 6,/*!< HVGA (480x320) */
        FRAME_FORMAT_VGA = 7,/*!< VGA (640x480) */
        FRAME_FORMAT_WXGA_H = 8,/*!< WXGA_H (1280x720) */
        FRAME_FORMAT_DS311 = 9,/*!< DS311 (320x120) */
        FRAME_FORMAT_XGA = 10,/*!< XGA (1024x768) */
        FRAME_FORMAT_SVGA = 11,/*!< SVGA (800x600) */
        FRAME_FORMAT_OVVGA = 12,/*!< OVVGA (636x480) */
        FRAME_FORMAT_WHVGA = 13,/*!< WHVGA (640x240) */
        FRAME_FORMAT_NHD = 14,/*!< nHD (640x360) */
        FRAME_FORMAT_STEREOLR = 15,/*!< StereoLR (320x480) */
        FRAME_FORMAT_INTERNAL_1280X240 = 1000,/*!< Internal resolution */
        FRAME_FORMAT_INTERNAL_2560X240 = 1001,/*!< Internal resolution */
        FRAME_FORMAT_INTERNAL_160X240 = 1002,/*!< Internal resolution */
        FRAME_FORMAT_INTERNAL_320X241 = 1003,/*!< Internal resolution */
        FRAME_FORMAT_INTERNAL_160X241 = 1004,/*!< Internal resolution */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String FrameFormat_toString_p (FrameFormat value);
    #endif
    /// Converts a DepthSense::FrameFormat value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::FrameFormat, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string FrameFormat_toString (FrameFormat value)
    {
        return FrameFormat_toString_p(value).unmarshal();
    }
    /// The image compression type
    ///
    /// A type enumerating the various compression types supported by
    /// DepthSense SDK.
    enum CompressionType
    {
        COMPRESSION_TYPE_YUY2 = 0,/*!< Y'UV422 */
        COMPRESSION_TYPE_MJPEG = 1,/*!< MJPEG */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CompressionType_toString_p (CompressionType value);
    #endif
    /// Converts a DepthSense::CompressionType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CompressionType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CompressionType_toString (CompressionType value)
    {
        return CompressionType_toString_p(value).unmarshal();
    }
    /// The auto exposure mode
    ///
    /// The supported auto exposure modes.
    enum ExposureAuto
    {
        EXPOSURE_AUTO_MANUAL = 0,/*!< Manual exposure mode */
        EXPOSURE_AUTO_APERTURE_PRIORITY = 1,/*!< Aperture priority exposure mode */
        EXPOSURE_AUTO_AUTO = 2,/*!< Auto exposure mode */
        EXPOSURE_AUTO_SHUTTER_PRIORITY = 3,/*!< Shutter priority exposure mode */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String ExposureAuto_toString_p (ExposureAuto value);
    #endif
    /// Converts a DepthSense::ExposureAuto value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::ExposureAuto, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string ExposureAuto_toString (ExposureAuto value)
    {
        return ExposureAuto_toString_p(value).unmarshal();
    }
    /// The power line frequency
    ///
    /// The supported power line frequencies.
    enum PowerLineFrequency
    {
        POWER_LINE_FREQUENCY_DISABLED = 0,/*!< disabled */
        POWER_LINE_FREQUENCY_50HZ = 1,/*!< 50 Hz */
        POWER_LINE_FREQUENCY_60HZ = 2,/*!< 60 Hz */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String PowerLineFrequency_toString_p (PowerLineFrequency value);
    #endif
    /// Converts a DepthSense::PowerLineFrequency value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::PowerLineFrequency, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string PowerLineFrequency_toString (PowerLineFrequency value)
    {
        return PowerLineFrequency_toString_p(value).unmarshal();
    }
    /// The camera plane to project on
    ///
    /// The camera plane to project the 3D points on.
    enum CameraPlane
    {
        CAMERA_PLANE_COLOR = 0,/*!< the color plane */
        CAMERA_PLANE_DEPTH = 1,/*!< the depth plane */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CameraPlane_toString_p (CameraPlane value);
    #endif
    /// Converts a DepthSense::CameraPlane value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CameraPlane, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CameraPlane_toString (CameraPlane value)
    {
        return CameraPlane_toString_p(value).unmarshal();
    }
    /// The sensor type
    ///
    /// The sensor type
    enum SensorType
    {
        SENSOR_TYPE_TEMPERATURE = 0,/*!< A temperature sensor */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String SensorType_toString_p (SensorType value);
    #endif
    /// Converts a DepthSense::SensorType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::SensorType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string SensorType_toString (SensorType value)
    {
        return SensorType_toString_p(value).unmarshal();
    }
    /// The dealiasing calibration mode
    ///
    /// A type enumerating the various dealiasing calibration modes supported by
    /// DepthSense SDK.
    enum DealiasingCalibrationMode
    {
        DEALIASING_CALIBRATION_MODE_NORMAL = 0,/*!< Normal */
        DEALIASING_CALIBRATION_MODE_F1 = 1,/*!< F1 */
        DEALIASING_CALIBRATION_MODE_F2 = 2,/*!< F2 */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String DealiasingCalibrationMode_toString_p (DealiasingCalibrationMode value);
    #endif
    /// Converts a DepthSense::DealiasingCalibrationMode value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DealiasingCalibrationMode, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string DealiasingCalibrationMode_toString (DealiasingCalibrationMode value)
    {
        return DealiasingCalibrationMode_toString_p(value).unmarshal();
    }
    /// The lens type
    ///
    /// A type enumerating the various lens types supported by
    /// DepthSense SDK.
    enum LensType
    {
        LENS_TYPE_INVALID = -1,/*!< Invalid */
        LENS_TYPE_N2A_BC170301A = 0,/*!< N2A_BC170301A */
        LENS_TYPE_NEWMAX_DS_8365A = 1,/*!< NEWMAX_DS_8365A */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String LensType_toString_p (LensType value);
    #endif
    /// Converts a DepthSense::LensType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::LensType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string LensType_toString (LensType value)
    {
        return LensType_toString_p(value).unmarshal();
    }
    /// The sensor type
    ///
    /// A type enumerating the various depth sensor types supported by
    /// DepthSense SDK.
    enum DepthSensorType
    {
        DEPTH_SENSOR_TYPE_INVALID = -1,/*!< Invalid */
        DEPTH_SENSOR_TYPE_X2544 = 0,/*!< X2544 */
        DEPTH_SENSOR_TYPE_OPT8241 = 1,/*!< OPT8241 */
        DEPTH_SENSOR_TYPE_MLX75023 = 2,/*!< MLX75023 */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String DepthSensorType_toString_p (DepthSensorType value);
    #endif
    /// Converts a DepthSense::DepthSensorType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthSensorType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string DepthSensorType_toString (DepthSensorType value)
    {
        return DepthSensorType_toString_p(value).unmarshal();
    }
    /// The illumination type
    ///
    /// A type enumerating the various illumination types supported by
    /// DepthSense SDK.
    enum IlluminationType
    {
        ILLUMINATION_TYPE_INVALID = -1,/*!< Invalid */
        ILLUMINATION_TYPE_TARA_75X51 = 0,/*!< TARA_75X51 */
        ILLUMINATION_TYPE_TARA_59X45 = 1,/*!< TARA_59X45 */
        ILLUMINATION_TYPE_TOMA_75X51 = 2,/*!< TOMA_75X51 */
        ILLUMINATION_TYPE_TOMA_59X45 = 3,/*!< TOMA_59X45 */
        ILLUMINATION_TYPE_TOMA_75X51_4W = 4,/*!< TOMA_75X51_4W */
        ILLUMINATION_TYPE_TOMA_59X45_4W = 5,/*!< TOMA_59X45_4W */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String IlluminationType_toString_p (IlluminationType value);
    #endif
    /// Converts a DepthSense::IlluminationType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::IlluminationType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string IlluminationType_toString (IlluminationType value)
    {
        return IlluminationType_toString_p(value).unmarshal();
    }
    /// The type of coordinate system
    ///
    /// The type of coordinate system
    enum CoordinateSystemType
    {
        COORDINATE_SYSTEM_TYPE_LEFT_HANDED = 0,/*!< A left handed coordinate system  */
        COORDINATE_SYSTEM_TYPE_RIGHT_HANDED = 1,/*!< A right handed coordinate system */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CoordinateSystemType_toString_p (CoordinateSystemType value);
    #endif
    /// Converts a DepthSense::CoordinateSystemType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CoordinateSystemType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CoordinateSystemType_toString (CoordinateSystemType value)
    {
        return CoordinateSystemType_toString_p(value).unmarshal();
    }
    /// The laser
    enum Laser
    {
        LASER_NONE = 0,
        LASER_ZERO = 1,
        LASER_ONE = 2,
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String Laser_toString_p (Laser value);
    #endif
    /// Converts a DepthSense::Laser value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Laser, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string Laser_toString (Laser value)
    {
        return Laser_toString_p(value).unmarshal();
    }
    namespace Depth
    {
        /// The type of IMU data 
        ///   
        /// A type enumerating the various types of IMU data.
        enum ImuDataType
        {
            IMU_DATA_TYPE_UNKNOWN = -1,/*!< unknown */
            IMU_DATA_TYPE_ACCELEROMETER = 65,/*!< Accelerometer */
            IMU_DATA_TYPE_COMPASS = 67,/*!< Compass */
            IMU_DATA_TYPE_GYROSCOPE = 71,/*!< Gyroscope */
            IMU_DATA_TYPE_CALIBRATION = 75,/*!< Calibration */
            IMU_DATA_TYPE_QUATERNION = 81,/*!< Quaternion */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DSI::String ImuDataType_toString_p (ImuDataType value);
        #endif
        /// Converts a DepthSense::Depth::ImuDataType value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Depth::ImuDataType, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string ImuDataType_toString (ImuDataType value)
        {
            return ImuDataType_toString_p(value).unmarshal();
        }
        /// The mode of the camera
        ///
        /// A type enumerating the various operating modes supported
        /// by depth sensors.
        enum CameraMode
        {
            CAMERA_MODE_UNKNOWN = -1,
            CAMERA_MODE_CLOSE_MODE = 0,
            CAMERA_MODE_LONG_RANGE = 1,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DSI::String CameraMode_toString_p (CameraMode value);
        #endif
        /// Converts a DepthSense::Depth::CameraMode value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Depth::CameraMode, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string CameraMode_toString (CameraMode value)
        {
            return CameraMode_toString_p(value).unmarshal();
        }
        /// Button ID
        enum ButtonID
        {
            BUTTON_IDBUTTON_0 = 0,
            BUTTON_IDBUTTON_1 = 1,
            BUTTON_IDBUTTON_2 = 2,
            BUTTON_IDBUTTON_3 = 3,
            BUTTON_IDBUTTON_4 = 4,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DSI::String ButtonID_toString_p (ButtonID value);
        #endif
        /// Converts a DepthSense::Depth::ButtonID value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Depth::ButtonID, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string ButtonID_toString (ButtonID value)
        {
            return ButtonID_toString_p(value).unmarshal();
        }
    };
};
namespace DepthSense
{
    /// \struct ModuleId DepthSense.hxx
    /// A structure defining the id of a module
    struct DEPTHSENSE_API ModuleId
    {
        ModuleId ();
        /// Constructs a ModuleId instance
        ///
        /// Constructs a ModuleId instance, initializing the instance fields with the provided values.
        ///
        /// \param moduleType the value of the ModuleId::moduleType field
        /// \param hwVersion the value of the ModuleId::hwVersion field
        /// \param serialNumber the value of the ModuleId::serialNumber field
        ModuleId (DepthSense::ModuleType moduleType, uint16_t hwVersion, uint32_t serialNumber);
        /// The DepthSense::ModuleType of the module
        DepthSense::ModuleType moduleType;
        /// The hardware version of the module
        uint16_t hwVersion;
        /// The serial number of the module
        uint32_t serialNumber;
        /// Compares two ModuleId instances for equality
        ///
        /// Checks whether the current ModuleId instance is equal to the ModuleId instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const ModuleId& other) const;
        /// Compares two ModuleId instances for inequality
        ///
        /// Checks whether the current ModuleId instance is different from the ModuleId instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const ModuleId& other) const;
    };
    /// \struct Vertex DepthSense.hxx
    /// A point in space as defined by its integer coordinates
    ///   
    /// The Vertex struct holds the position of a point in space as
    /// defined by its 3D integer coordinates.
    struct DEPTHSENSE_API Vertex
    {
        Vertex ();
        /// Constructs a Vertex instance
        ///
        /// Constructs a Vertex instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the Vertex::x field
        /// \param y the value of the Vertex::y field
        /// \param z the value of the Vertex::z field
        Vertex (int16_t x, int16_t y, int16_t z);
        /// the x value
        int16_t x;
        /// the y value
        int16_t y;
        /// the z value
        int16_t z;
        /// Compares two Vertex instances for equality
        ///
        /// Checks whether the current Vertex instance is equal to the Vertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Vertex& other) const;
        /// Compares two Vertex instances for inequality
        ///
        /// Checks whether the current Vertex instance is different from the Vertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Vertex& other) const;
    };
    /// \struct FPVertex DepthSense.hxx
    /// A point in space as defined by its floating point coordinates
    ///   
    /// The FPVertex struct holds the position of a point in space as
    /// defined by its 3D floating point coordinates.
    struct DEPTHSENSE_API FPVertex
    {
        FPVertex ();
        /// Constructs a FPVertex instance
        ///
        /// Constructs a FPVertex instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the FPVertex::x field
        /// \param y the value of the FPVertex::y field
        /// \param z the value of the FPVertex::z field
        FPVertex (float x, float y, float z);
        /// the x value
        float x;
        /// the y value
        float y;
        /// the z value
        float z;
        /// Compares two FPVertex instances for equality
        ///
        /// Checks whether the current FPVertex instance is equal to the FPVertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const FPVertex& other) const;
        /// Compares two FPVertex instances for inequality
        ///
        /// Checks whether the current FPVertex instance is different from the FPVertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const FPVertex& other) const;
    };
    /// \struct UV DepthSense.hxx
    /// UV coordinates
    ///   
    /// The UV struct holds the UV coordinates of a point of a UV map.
    struct DEPTHSENSE_API UV
    {
        UV ();
        /// Constructs a UV instance
        ///
        /// Constructs a UV instance, initializing the instance fields with the provided values.
        ///
        /// \param u the value of the UV::u field
        /// \param v the value of the UV::v field
        UV (float u, float v);
        /// the u value
        float u;
        /// the v value
        float v;
        /// Compares two UV instances for equality
        ///
        /// Checks whether the current UV instance is equal to the UV instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const UV& other) const;
        /// Compares two UV instances for inequality
        ///
        /// Checks whether the current UV instance is different from the UV instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const UV& other) const;
    };
    /// \struct IntrinsicParameters DepthSense.hxx
    /// The intrinsic parameters of the camera system
    ///   
    /// The IntrinsicParameters struct holds the intrinsic parameters
    /// of the camera system.
    struct DEPTHSENSE_API IntrinsicParameters
    {
        IntrinsicParameters ();
        /// Constructs a IntrinsicParameters instance
        ///
        /// Constructs a IntrinsicParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param width the value of the IntrinsicParameters::width field
        /// \param height the value of the IntrinsicParameters::height field
        /// \param fx the value of the IntrinsicParameters::fx field
        /// \param fy the value of the IntrinsicParameters::fy field
        /// \param cx the value of the IntrinsicParameters::cx field
        /// \param cy the value of the IntrinsicParameters::cy field
        /// \param k1 the value of the IntrinsicParameters::k1 field
        /// \param k2 the value of the IntrinsicParameters::k2 field
        /// \param k3 the value of the IntrinsicParameters::k3 field
        /// \param p1 the value of the IntrinsicParameters::p1 field
        /// \param p2 the value of the IntrinsicParameters::p2 field
        IntrinsicParameters (int32_t width, int32_t height, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2);
        /// the width of the map when the frame was captured
        int32_t width;
        /// the height of the map when the frame was captured
        int32_t height;
        /// the focal length along the x axis, expressed in pixel units
        float fx;
        /// the focal length along the y axis, expressed in pixel units
        float fy;
        /// the central point along the x axis, expressed in pixel units
        float cx;
        /// the central point along the y axis, expressed in pixel units
        float cy;
        /// the first radial distortion coefficient
        float k1;
        /// the second radial distortion coefficient
        float k2;
        /// the third radial distortion coefficient
        float k3;
        /// the first tangential distortion coefficient
        float p1;
        /// the second tangential distortion coefficient
        float p2;
        /// Compares two IntrinsicParameters instances for equality
        ///
        /// Checks whether the current IntrinsicParameters instance is equal to the IntrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const IntrinsicParameters& other) const;
        /// Compares two IntrinsicParameters instances for inequality
        ///
        /// Checks whether the current IntrinsicParameters instance is different from the IntrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const IntrinsicParameters& other) const;
    };
    /// \struct ExtrinsicParameters DepthSense.hxx
    /// The extrinsic parameters of the camera system
    ///   
    /// The ExtrinsicsParameters struct holds the extrinsic parameters
    /// of the camera system. Elements are given row by row.
    struct DEPTHSENSE_API ExtrinsicParameters
    {
        ExtrinsicParameters ();
        /// Constructs a ExtrinsicParameters instance
        ///
        /// Constructs a ExtrinsicParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param r11 the value of the ExtrinsicParameters::r11 field
        /// \param r12 the value of the ExtrinsicParameters::r12 field
        /// \param r13 the value of the ExtrinsicParameters::r13 field
        /// \param r21 the value of the ExtrinsicParameters::r21 field
        /// \param r22 the value of the ExtrinsicParameters::r22 field
        /// \param r23 the value of the ExtrinsicParameters::r23 field
        /// \param r31 the value of the ExtrinsicParameters::r31 field
        /// \param r32 the value of the ExtrinsicParameters::r32 field
        /// \param r33 the value of the ExtrinsicParameters::r33 field
        /// \param t1 the value of the ExtrinsicParameters::t1 field
        /// \param t2 the value of the ExtrinsicParameters::t2 field
        /// \param t3 the value of the ExtrinsicParameters::t3 field
        ExtrinsicParameters (float r11, float r12, float r13, float r21, float r22, float r23, float r31, float r32, float r33, float t1, float t2, float t3);
        /// the r11 parameter
        float r11;
        /// the r12 parameter
        float r12;
        /// the r13 parameter
        float r13;
        /// the r21 parameter
        float r21;
        /// the r22 parameter
        float r22;
        /// the r32 parameter
        float r23;
        /// the r31 parameter
        float r31;
        /// the r32 parameter
        float r32;
        /// the r33 parameter
        float r33;
        /// the t1 parameter
        float t1;
        /// the t2 parameter
        float t2;
        /// the t3 parameter
        float t3;
        /// Compares two ExtrinsicParameters instances for equality
        ///
        /// Checks whether the current ExtrinsicParameters instance is equal to the ExtrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const ExtrinsicParameters& other) const;
        /// Compares two ExtrinsicParameters instances for inequality
        ///
        /// Checks whether the current ExtrinsicParameters instance is different from the ExtrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const ExtrinsicParameters& other) const;
    };
    /// \struct StereoCameraParameters DepthSense.hxx
    /// The intrinsic and extrinsic parameters of the camera system
    ///   
    /// The StereoCameraParameters holds the intrinsic and extrinsic
    /// parameters of the camera system.
    struct DEPTHSENSE_API StereoCameraParameters
    {
        StereoCameraParameters ();
        /// Constructs a StereoCameraParameters instance
        ///
        /// Constructs a StereoCameraParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param depthIntrinsics the value of the StereoCameraParameters::depthIntrinsics field
        /// \param colorIntrinsics the value of the StereoCameraParameters::colorIntrinsics field
        /// \param extrinsics the value of the StereoCameraParameters::extrinsics field
        StereoCameraParameters (DepthSense::IntrinsicParameters depthIntrinsics, DepthSense::IntrinsicParameters colorIntrinsics, DepthSense::ExtrinsicParameters extrinsics);
        /// The intrinsic parameters of the depth camera
        DepthSense::IntrinsicParameters depthIntrinsics;
        /// The intrinsic parameters of the color camera
        DepthSense::IntrinsicParameters colorIntrinsics;
        /// The extrinsic parameters of the system. The coordinate system used 
        /// is the one specified through \c DepthNode::coordinateSystemType property.
        DepthSense::ExtrinsicParameters extrinsics;
        /// Compares two StereoCameraParameters instances for equality
        ///
        /// Checks whether the current StereoCameraParameters instance is equal to the StereoCameraParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const StereoCameraParameters& other) const;
        /// Compares two StereoCameraParameters instances for inequality
        ///
        /// Checks whether the current StereoCameraParameters instance is different from the StereoCameraParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const StereoCameraParameters& other) const;
    };
    /// \struct SensorValue DepthSense.hxx
    /// The value read from a sensor of the device
    struct DEPTHSENSE_API SensorValue
    {
        SensorValue ();
        /// Constructs a SensorValue instance
        ///
        /// Constructs a SensorValue instance, initializing the instance fields with the provided values.
        ///
        /// \param type the value of the SensorValue::type field
        /// \param address the value of the SensorValue::address field
        /// \param val the value of the SensorValue::val field
        SensorValue (DepthSense::SensorType type, uint32_t address, float val);
        /// The type of sensor
        DepthSense::SensorType type;
        /// The address of the sensor (can be the i2c address)
        uint32_t address;
        /// The value read from the sensor
        float val;
        /// Compares two SensorValue instances for equality
        ///
        /// Checks whether the current SensorValue instance is equal to the SensorValue instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const SensorValue& other) const;
        /// Compares two SensorValue instances for inequality
        ///
        /// Checks whether the current SensorValue instance is different from the SensorValue instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const SensorValue& other) const;
    };
    /// \struct Point2D DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates
    ///
    /// The Point2D struct holds the position of a point in the
    /// cartesian space as defined by its floating point pixel
    /// coordinates. The origin of the coordinate system is the
    /// topleft corner of the image.
    struct DEPTHSENSE_API Point2D
    {
        Point2D ();
        /// Constructs a Point2D instance
        ///
        /// Constructs a Point2D instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the Point2D::x field
        /// \param y the value of the Point2D::y field
        Point2D (float x, float y);
        /// the x coordinate
        float x;
        /// the y coordinate
        float y;
        /// Compares two Point2D instances for equality
        ///
        /// Checks whether the current Point2D instance is equal to the Point2D instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Point2D& other) const;
        /// Compares two Point2D instances for inequality
        ///
        /// Checks whether the current Point2D instance is different from the Point2D instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Point2D& other) const;
    };
    /// \struct Extended2DPoint DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates, and its integral cartesian depth
    ///
    /// The Extended2DPoint struct holds the position of a point in
    /// the cartesian space as defined by its floating point pixel
    /// coordinates, and its integral cartesian depth.
    struct DEPTHSENSE_API Extended2DPoint
    {
        Extended2DPoint ();
        /// Constructs a Extended2DPoint instance
        ///
        /// Constructs a Extended2DPoint instance, initializing the instance fields with the provided values.
        ///
        /// \param point the value of the Extended2DPoint::point field
        /// \param depth the value of the Extended2DPoint::depth field
        Extended2DPoint (DepthSense::Point2D point, int16_t depth);
        /// the coordinates of the 2D point
        DepthSense::Point2D point;
        /// the depth at this location, expressed in millimeters
        int16_t depth;
        /// Compares two Extended2DPoint instances for equality
        ///
        /// Checks whether the current Extended2DPoint instance is equal to the Extended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Extended2DPoint& other) const;
        /// Compares two Extended2DPoint instances for inequality
        ///
        /// Checks whether the current Extended2DPoint instance is different from the Extended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Extended2DPoint& other) const;
    };
    /// \struct FPExtended2DPoint DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates, and its floating point cartesian
    /// depth
    ///
    /// The FPExtended2DPoint struct holds the position of a point in
    /// the cartesian space as defined by its floating point pixel
    /// coordinates, and its floating point cartesian depth.
    struct DEPTHSENSE_API FPExtended2DPoint
    {
        FPExtended2DPoint ();
        /// Constructs a FPExtended2DPoint instance
        ///
        /// Constructs a FPExtended2DPoint instance, initializing the instance fields with the provided values.
        ///
        /// \param point the value of the FPExtended2DPoint::point field
        /// \param depth the value of the FPExtended2DPoint::depth field
        FPExtended2DPoint (DepthSense::Point2D point, float depth);
        /// the coordinates of the 2D point
        DepthSense::Point2D point;
        /// the depth at this location.
        float depth;
        /// Compares two FPExtended2DPoint instances for equality
        ///
        /// Checks whether the current FPExtended2DPoint instance is equal to the FPExtended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const FPExtended2DPoint& other) const;
        /// Compares two FPExtended2DPoint instances for inequality
        ///
        /// Checks whether the current FPExtended2DPoint instance is different from the FPExtended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const FPExtended2DPoint& other) const;
    };
    /// \struct Version DepthSense.hxx
    /// DepthSense version information
    ///
    /// The Version struct contains version information for the DepthSenseSDK software.
    struct DEPTHSENSE_API Version
    {
        Version ();
        /// Constructs a Version instance
        ///
        /// Constructs a Version instance, initializing the instance fields with the provided values.
        ///
        /// \param major the value of the Version::major field
        /// \param minor the value of the Version::minor field
        /// \param patch the value of the Version::patch field
        /// \param build the value of the Version::build field
        Version (int32_t major, int32_t minor, int32_t patch, int32_t build);
        /// the major version number
        int32_t major;
        /// the minor version number
        int32_t minor;
        /// the patch level
        int32_t patch;
        /// the package build number
        int32_t build;
        /// Compares two Version instances for equality
        ///
        /// Checks whether the current Version instance is equal to the Version instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Version& other) const;
        /// Compares two Version instances for inequality
        ///
        /// Checks whether the current Version instance is different from the Version instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Version& other) const;
    };
    /// \struct RegionOfInterest DepthSense.hxx
    /// A Region of Interest
    ///
    /// The RegionOfInterest structure holds the position of the top
    /// left corner and the bottom right corner of the region of
    /// interest
    struct DEPTHSENSE_API RegionOfInterest
    {
        RegionOfInterest ();
        /// Constructs a RegionOfInterest instance
        ///
        /// Constructs a RegionOfInterest instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the RegionOfInterest::x field
        /// \param y the value of the RegionOfInterest::y field
        /// \param width the value of the RegionOfInterest::width field
        /// \param height the value of the RegionOfInterest::height field
        RegionOfInterest (int32_t x, int32_t y, int32_t width, int32_t height);
        int32_t x;
        int32_t y;
        int32_t width;
        int32_t height;
        /// Compares two RegionOfInterest instances for equality
        ///
        /// Checks whether the current RegionOfInterest instance is equal to the RegionOfInterest instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const RegionOfInterest& other) const;
        /// Compares two RegionOfInterest instances for inequality
        ///
        /// Checks whether the current RegionOfInterest instance is different from the RegionOfInterest instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const RegionOfInterest& other) const;
    };
    namespace Audio
    {
        /// \struct Configuration DepthSense.hxx
        /// The configuration of an audio node
        ///   
        /// The Configuration struct holds the configuration of an audio node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param channels the value of the Configuration::channels field
            /// \param bitsPerSample the value of the Configuration::bitsPerSample field
            /// \param sampleRate the value of the Configuration::sampleRate field
            Configuration (int32_t channels, int32_t bitsPerSample, int32_t sampleRate);
            /// the number of audio channels
            int32_t channels;
            /// the number of bits per sample
            int32_t bitsPerSample;
            /// the sample rate in Hz
            int32_t sampleRate;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
    };
    namespace Color
    {
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a color node
        ///   
        /// The Configuration struct holds the configuration of a color node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param powerLineFrequency the value of the Configuration::powerLineFrequency field
            /// \param compression the value of the Configuration::compression field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::PowerLineFrequency powerLineFrequency, DepthSense::CompressionType compression);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the power line frequency in Hz
            DepthSense::PowerLineFrequency powerLineFrequency;
            /// the compression type
            DepthSense::CompressionType compression;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
    };
    namespace Depth
    {
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a depth node
        ///   
        /// The Configuration struct holds the configuration of a depth node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param mode the value of the Configuration::mode field
            /// \param saturation the value of the Configuration::saturation field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::Depth::CameraMode mode, bool saturation);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the mode
            DepthSense::Depth::CameraMode mode;
            /// whether the saturation is enabled or not
            bool saturation;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// \struct Acceleration DepthSense.hxx
        /// The acceleration returned by the camera
        ///
        /// The Acceleration struct holds the 3 axis acceleration
        /// expressed in g (9.81 m/s) units. Coordinates are
        /// expressed in the same coordinates as the vertices.
        struct DEPTHSENSE_API Acceleration
        {
            Acceleration ();
            /// Constructs a Acceleration instance
            ///
            /// Constructs a Acceleration instance, initializing the instance fields with the provided values.
            ///
            /// \param x the value of the Acceleration::x field
            /// \param y the value of the Acceleration::y field
            /// \param z the value of the Acceleration::z field
            Acceleration (float x, float y, float z);
            /// the x acceleration
            float x;
            /// the y acceleration
            float y;
            /// the z acceleration
            float z;
            /// Compares two Acceleration instances for equality
            ///
            /// Checks whether the current Acceleration instance is equal to the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Acceleration& other) const;
            /// Compares two Acceleration instances for inequality
            ///
            /// Checks whether the current Acceleration instance is different from the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Acceleration& other) const;
        };
    };
};
namespace DepthSense
{
    /// \class Exception DepthSense.hxx
    /// The base exception class
    ///   
    /// The Exception class is the common base class for all
    /// DepthSense exception types. It is never thrown directly, one
    /// of its subclasses is.
    ///
    /// DepthSense exceptions feature automatic memory management,
    /// implemented with reference counted smart pointer mechanisms.
    ///
    /// The Exception class derives from \c std::exception.
    class DEPTHSENSE_API Exception : public std::exception
    {
        #ifndef DEPTHSENSE_DOC
        protected:
        void* _data;
        #endif
        public:
        #ifndef DEPTHSENSE_DOC
        Exception (const Exception& other);
        Exception& operator= (const Exception& other);
        virtual ~Exception () throw ();
        virtual const char* what () const throw ();
        #endif
        protected:
        Exception ();
        Exception (void* data);
        private:
        Exception (DepthSense::Utils::BinaryReader& reader);
        #ifndef DEPTHSENSE_DOC
        protected:
        void setMessage (std::string value);
        #endif
        public:
        /// Returns the error message
        ///   
        /// Returns the error message contained in the current
        /// exception object.
        ///
        /// \return the error message
        std::string getMessage () const;
        private:
        friend class PException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class ArgumentException DepthSense.hxx
    /// The type of the exception thrown when an argument is unset or invalid
    ///   
    /// ArgumentException is thrown when a method argument or property
    /// value is unset when it should be set or is outside of the
    /// range of allowed values.
    class DEPTHSENSE_API ArgumentException : public DepthSense::Exception
    {
        protected:
        ArgumentException ();
        ArgumentException (void* data);
        private:
        ArgumentException (DepthSense::Utils::BinaryReader& reader);
        #ifndef DEPTHSENSE_DOC
        protected:
        void setParameterName (std::string value);
        #endif
        public:
        /// Returns the name of the corresponding parameter
        ///   
        /// Returns the name of the method parameter whose argument is
        /// invalid. For a property value, this name is always \c
        /// value.
        ///
        /// \return the parameter name
        std::string getParameterName () const;
        private:
        friend class PArgumentException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class TransportException DepthSense.hxx
    /// The type of the exception thrown when a network or protocol
    /// error has occurred
    ///
    /// TransportException is thrown when a network I/O operation has
    /// failed, or when an invalid protocol packet has been received.
    class DEPTHSENSE_API TransportException : public DepthSense::Exception
    {
        protected:
        TransportException ();
        TransportException (void* data);
        private:
        TransportException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PTransportException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class InitializationException DepthSense.hxx
    /// The type of the exception thrown when an initialization error
    /// has occurred
    ///
    /// InitializationException is thrown when a component has failed
    /// to initialize properly.
    class DEPTHSENSE_API InitializationException : public DepthSense::Exception
    {
        protected:
        InitializationException ();
        InitializationException (void* data);
        private:
        InitializationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PInitializationException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class TimeoutException DepthSense.hxx
    /// The type of the exception thrown when a timeout condition occurs
    ///
    /// TimeoutException is thrown when the user-provided timeout of a
    /// method accepting a timeout parameter expires.
    class DEPTHSENSE_API TimeoutException : public DepthSense::Exception
    {
        protected:
        TimeoutException ();
        TimeoutException (void* data);
        private:
        TimeoutException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PTimeoutException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class ConfigurationException DepthSense.hxx
    /// The type of the exception thrown when a valid configuration
    /// failed to apply
    ///   
    /// ConfigurationException is thrown when a valid configuration
    /// could not be applied because of a device or software error.
    ///
    /// Contrast with ArgumentException, which is thrown by
    /// AudioNode::setConfiguration(), ColorNode::setConfiguration()
    /// and DepthNode::setConfiguration() when the user-provided
    /// configuration is invalid.
    class DEPTHSENSE_API ConfigurationException : public DepthSense::Exception
    {
        protected:
        ConfigurationException ();
        ConfigurationException (void* data);
        private:
        ConfigurationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PConfigurationException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class StreamingException DepthSense.hxx
    /// The type of the exception thrown when a streaming error has
    /// occurred
    ///
    /// StreamingException is thrown when a device or software error
    /// prevents streaming from starting or from resuming after a
    /// configuration change.
    class DEPTHSENSE_API StreamingException : public DepthSense::Exception
    {
        protected:
        StreamingException ();
        StreamingException (void* data);
        private:
        StreamingException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PStreamingException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class UnauthorizedAccessException DepthSense.hxx
    /// The type of the exception thrown when access to a privileged
    /// operation is denied
    ///    
    /// UnauthorizedAccessException is thrown when a privileged method
    /// is called or when a privileged property is set.
    ///
    /// A privileged method or property is one which requires
    /// exclusive control of a device or node. Such exclusive control
    /// can be obtained with a call to Context::requestControl().
    class DEPTHSENSE_API UnauthorizedAccessException : public DepthSense::Exception
    {
        protected:
        UnauthorizedAccessException ();
        UnauthorizedAccessException (void* data);
        private:
        UnauthorizedAccessException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PUnauthorizedAccessException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class InvalidOperationException DepthSense.hxx
    /// The type of the exception thrown when the current state of an
    /// object does not support the requested operation
    ///   
    /// InvalidOperationException is thrown when an operation is not valid
    /// because of the current state of an object.
    ///
    /// Contrast with NotSupportedException, which is thrown when an
    /// operation is not implemented, regardless of any program or
    /// library state.
    class DEPTHSENSE_API InvalidOperationException : public DepthSense::Exception
    {
        protected:
        InvalidOperationException ();
        InvalidOperationException (void* data);
        private:
        InvalidOperationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PInvalidOperationException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class NotSupportedException DepthSense.hxx
    /// The type of the exception thrown when a unsupported operation
    /// is requested
    ///
    /// NotSupportedException is thrown when an unimplemented method
    /// or property is used.
    class DEPTHSENSE_API NotSupportedException : public DepthSense::Exception
    {
        protected:
        NotSupportedException ();
        NotSupportedException (void* data);
        private:
        NotSupportedException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PNotSupportedException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class IOException DepthSense.hxx
    /// The type of the exception throw when a device or file I/O
    /// operation has failed
    ///   
    /// IOException is thrown when an operation on a device or a file
    /// has failed because of an I/O error.
    class DEPTHSENSE_API IOException : public DepthSense::Exception
    {
        protected:
        IOException ();
        IOException (void* data);
        private:
        IOException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PIOException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    namespace Audio
    {
    };
    namespace Color
    {
    };
    namespace Depth
    {
    };
};
namespace DepthSense
{
    /// \class Interface DepthSense.hxx
    /// The base interface class
    ///
    /// The Interface class is the common base class for all
    /// DepthSense interfaces. It provides facilities for
    /// introspecting the runtime type of an object and for setting or
    /// unsetting the current instance.
    ///
    /// The Interface class and its subclasses feature automatic
    /// memory management, implemented with reference counted smart
    /// pointer mechanisms.
    class Interface
    {
        private:
        void* _instance;
        DEPTHSENSE_API Interface (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Interface ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Interface (const Interface& other);
        DEPTHSENSE_API Interface& operator= (const Interface& other);
        #endif
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        DEPTHSENSE_API ~Interface ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Interface (const DepthSense::Audio::SampleData& iface);
        DEPTHSENSE_API Interface (const DepthSense::AudioNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::Color::SampleData& iface);
        DEPTHSENSE_API Interface (const DepthSense::ColorNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::GPIOValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::FloatParameterValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::BoolParameterValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::IntParameterValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::RegionOfInterestValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::I2CArrayValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::RegisterValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::SystemInfoValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::SystemCalibrationValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::TemperatureCorrection& iface);
        DEPTHSENSE_API Interface (const DepthSense::CyclicErrorCorrection& iface);
        DEPTHSENSE_API Interface (const DepthSense::GradientDistortionCorrection& iface);
        DEPTHSENSE_API Interface (const DepthSense::Calibration& iface);
        DEPTHSENSE_API Interface (const DepthSense::HardwareVersion& iface);
        DEPTHSENSE_API Interface (const DepthSense::SystemStateValue& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::IMUData& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::SampleData& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::ButtonEventData& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::SampleDataEx& iface);
        DEPTHSENSE_API Interface (const DepthSense::DepthNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::UnsupportedNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::Context& iface);
        DEPTHSENSE_API Interface (const DepthSense::Device& iface);
        DEPTHSENSE_API Interface (const DepthSense::Node& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Interface& other) const;
        #endif
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        /// Returns the DepthSense::Interface type object
        ///
        /// Returns the DepthSense::Interface type object
        ///
        /// \return the DepthSense::Interface type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct PropertyChangedData DepthSense.hxx
        /// Holds the DepthSense::Interface::PropertyChangedEvent arguments
        ///
        /// The PropertyChangedData struct holds the DepthSense::Interface::PropertyChangedEvent parameters and is passed to callbacks connected to that event.
        struct PropertyChangedData
        {
            /// the property whose value has changed
            DepthSense::PropertyBase property;
        };
        /// \class PropertyChangedEvent DepthSense.hxx
        /// Event raised when a property has changed
        ///
        /// The \c propertyChanged event is raised when the value of a
        /// property has changed.
        ///
        /// \param property the property whose value has changed
        class PropertyChangedEvent : public DepthSense::Event<DepthSense::Interface, PropertyChangedData>
        {
            private:
            PropertyChangedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Interface, PropertyChangedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>(func)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    _func(obj, data.property);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    _func(obj, data.property, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::_method))(obj, data.property);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::FunctionHandler<DepthSense::Interface, PropertyChangedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Interface, PropertyChangedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::ClosureHandler<DepthSense::Interface, PropertyChangedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Interface, PropertyChangedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Interface obj, DepthSense::PropertyBase property, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Interface obj, DepthSense::PropertyBase property, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::MethodHandler<DepthSense::Interface, PropertyChangedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Interface, PropertyChangedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
    };
    /// \class Node DepthSense.hxx
    /// Represents a stream data source
    ///   
    /// The Node class represents a stream data source belonging to a given
    /// device. A device may contain several nodes (depth and color sensors,
    /// and a microphone array).
    class Node
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Node (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        public:
        DEPTHSENSE_API Node ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Node (const Node& other);
        DEPTHSENSE_API Node& operator= (const Node& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Node ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Node (const DepthSense::Interface& iface);
        DEPTHSENSE_API Node (const DepthSense::AudioNode& iface);
        DEPTHSENSE_API Node (const DepthSense::ColorNode& iface);
        DEPTHSENSE_API Node (const DepthSense::DepthNode& iface);
        DEPTHSENSE_API Node (const DepthSense::UnsupportedNode& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Node& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Node type object
        ///
        /// Returns the DepthSense::Node type object
        ///
        /// \return the DepthSense::Node type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Audio
    {
        /// \class SampleData DepthSense.hxx
        /// A class holding all the sample data
        class SampleData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::BaseValue;
            friend class DepthSense::GPIOValue;
            friend class DepthSense::FloatParameterValue;
            friend class DepthSense::BoolParameterValue;
            friend class DepthSense::IntParameterValue;
            friend class DepthSense::RegionOfInterestValue;
            friend class DepthSense::I2CArrayValue;
            friend class DepthSense::RegisterValue;
            friend class DepthSense::SystemInfoValue;
            friend class DepthSense::SystemCalibrationValue;
            friend class DepthSense::TemperatureCorrection;
            friend class DepthSense::CyclicErrorCorrection;
            friend class DepthSense::GradientDistortionCorrection;
            friend class DepthSense::Calibration;
            friend class DepthSense::HardwareVersion;
            friend class DepthSense::SystemStateValue;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::Depth::SampleDataEx;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleData (const SampleData& other);
            DEPTHSENSE_API SampleData& operator= (const SampleData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Audio::SampleData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Audio::SampleData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Audio::SampleData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Audio::SampleData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Audio::SampleData type object
            ///
            /// Returns the DepthSense::Audio::SampleData type object
            ///
            /// \return the DepthSense::Audio::SampleData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The audio data.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint8_t > audioData;
            #endif
            /// Gets the value of the SampleData::audioData property
            ///
            /// Gets the value of the SampleData::audioData property.
            ///
            ///
            /// \return the value of the SampleData::audioData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint8_t > getAudioData ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Audio::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleData::captureConfiguration property
            ///
            /// Gets the value of the SampleData::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleData::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Audio::Configuration getCaptureConfiguration ();
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleData::timeOfCapture property
            ///
            /// Gets the value of the SampleData::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleData::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// The time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleData::timeOfArrival property
            ///
            /// Gets the value of the SampleData::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleData::droppedSampleCount property
            ///
            /// Gets the value of the SampleData::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    /// \class AudioNode DepthSense.hxx
    /// Represents an audio stream data source
    ///   
    /// The AudioNode class allows to capture audio data with the microphone
    /// array of a given camera device.
    class AudioNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API AudioNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API AudioNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API AudioNode (const AudioNode& other);
        DEPTHSENSE_API AudioNode& operator= (const AudioNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~AudioNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit AudioNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit AudioNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::AudioNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::AudioNode type object
        ///
        /// Returns the DepthSense::AudioNode type object
        ///
        /// \return the DepthSense::AudioNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct Configuration DepthSense.hxx
        /// The configuration of an audio node
        ///   
        /// The Configuration struct holds the configuration of an audio node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param channels the value of the Configuration::channels field
            /// \param bitsPerSample the value of the Configuration::bitsPerSample field
            /// \param sampleRate the value of the Configuration::sampleRate field
            Configuration (int32_t channels, int32_t bitsPerSample, int32_t sampleRate);
            /// the number of audio channels
            int32_t channels;
            /// the number of bits per sample
            int32_t bitsPerSample;
            /// the sample rate in Hz
            int32_t sampleRate;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// The node configuration
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::AudioNode::Configuration configuration;
        #endif
        /// Gets the value of the AudioNode::configuration property
        ///
        /// Gets the value of the AudioNode::configuration property.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::Configuration getConfiguration ();
        /// Sets the value of the AudioNode::configuration property
        ///
        /// Sets the value of the AudioNode::configuration property.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::AudioNode::Configuration value);
        /// Checks whether property AudioNode::configuration is read-only
        ///
        /// Checks whether property AudioNode::configuration is read-only.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The AudioNode::configurations property specifies the list of
        /// supported node configurations.
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::AudioNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::AudioNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the AudioNode::configurations property
        ///
        /// Gets the value of the AudioNode::configurations property.
        ///
        ///
        /// \return the value of the AudioNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::AudioNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::AudioNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The recording level
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property float inputMixerLevel;
        #endif
        /// Gets the value of the AudioNode::inputMixerLevel property
        ///
        /// Gets the value of the AudioNode::inputMixerLevel property.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::inputMixerLevel property
        ///
        /// \sa setInputMixerLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getInputMixerLevel ();
        /// Sets the value of the AudioNode::inputMixerLevel property
        ///
        /// Sets the value of the AudioNode::inputMixerLevel property.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getInputMixerLevel(), inputMixerLevelIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setInputMixerLevel (float value);
        /// Checks whether property AudioNode::inputMixerLevel is read-only
        ///
        /// Checks whether property AudioNode::inputMixerLevel is read-only.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::inputMixerLevel is read-only
        ///
        /// \sa setInputMixerLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool inputMixerLevelIsReadOnly ();
        /// Whether to mute the recording
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool mute;
        #endif
        /// Gets the value of the AudioNode::mute property
        ///
        /// Gets the value of the AudioNode::mute property.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::mute property
        ///
        /// \sa setMute()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getMute ();
        /// Sets the value of the AudioNode::mute property
        ///
        /// Sets the value of the AudioNode::mute property.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getMute(), muteIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setMute (bool value);
        /// Checks whether property AudioNode::mute is read-only
        ///
        /// Checks whether property AudioNode::mute is read-only.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::mute is read-only
        ///
        /// \sa setMute()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool muteIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::AudioNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::AudioNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// the audio data
            ::DepthSense::Pointer< uint8_t > audioData;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::AudioNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when an audio sample is captured
        ///
        /// The \c newSampleReceived event is raised when an audio sample
        /// is captured.
        ///
        /// \param audioData the audio data
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        /// \struct NewSampleReceived2Data DepthSense.hxx
        /// Holds the DepthSense::AudioNode::NewSampleReceived2Event arguments
        ///
        /// The NewSampleReceived2Data struct holds the DepthSense::AudioNode::NewSampleReceived2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceived2Data
        {
            DepthSense::Audio::SampleData data;
        };
        /// \class NewSampleReceived2Event DepthSense.hxx
        /// Event raised when an audio sample is captured
        ///
        /// The \c newSampleReceived2 event is raised when an audio sample
        /// is captured.                         
        class NewSampleReceived2Event : public DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>
        {
            private:
            NewSampleReceived2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>(func)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceived2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived2 event object
        ///
        /// Returns a reference to the \c newSampleReceived2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::NewSampleReceived2Event& newSampleReceived2Event () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Color
    {
        /// \class SampleData DepthSense.hxx
        /// A class holding all the sample data
        class SampleData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::ColorNode;
            friend class DepthSense::BaseValue;
            friend class DepthSense::GPIOValue;
            friend class DepthSense::FloatParameterValue;
            friend class DepthSense::BoolParameterValue;
            friend class DepthSense::IntParameterValue;
            friend class DepthSense::RegionOfInterestValue;
            friend class DepthSense::I2CArrayValue;
            friend class DepthSense::RegisterValue;
            friend class DepthSense::SystemInfoValue;
            friend class DepthSense::SystemCalibrationValue;
            friend class DepthSense::TemperatureCorrection;
            friend class DepthSense::CyclicErrorCorrection;
            friend class DepthSense::GradientDistortionCorrection;
            friend class DepthSense::Calibration;
            friend class DepthSense::HardwareVersion;
            friend class DepthSense::SystemStateValue;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::Depth::SampleDataEx;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleData (const SampleData& other);
            DEPTHSENSE_API SampleData& operator= (const SampleData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Color::SampleData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Color::SampleData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Color::SampleData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Color::SampleData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Color::SampleData type object
            ///
            /// Returns the DepthSense::Color::SampleData type object
            ///
            /// \return the DepthSense::Color::SampleData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint8_t > colorMap;
            #endif
            /// Gets the value of the SampleData::colorMap property
            ///
            /// Gets the value of the SampleData::colorMap property.
            ///
            ///
            /// \return the value of the SampleData::colorMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint8_t > getColorMap ();
            /// The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint8_t > compressedData;
            #endif
            /// Gets the value of the SampleData::compressedData property
            ///
            /// Gets the value of the SampleData::compressedData property.
            ///
            ///
            /// \return the value of the SampleData::compressedData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint8_t > getCompressedData ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Color::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleData::captureConfiguration property
            ///
            /// Gets the value of the SampleData::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleData::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Color::Configuration getCaptureConfiguration ();
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleData::timeOfCapture property
            ///
            /// Gets the value of the SampleData::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleData::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// The time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleData::timeOfArrival property
            ///
            /// Gets the value of the SampleData::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleData::droppedSampleCount property
            ///
            /// Gets the value of the SampleData::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    /// \class ColorNode DepthSense.hxx
    /// Represents a color stream data source
    ///
    /// The ColorNode class allows to capture pixel data with the RGB sensor
    /// of a given camera device.
    class ColorNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API ColorNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API ColorNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API ColorNode (const ColorNode& other);
        DEPTHSENSE_API ColorNode& operator= (const ColorNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~ColorNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit ColorNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit ColorNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::ColorNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::ColorNode type object
        ///
        /// Returns the DepthSense::ColorNode type object
        ///
        /// \return the DepthSense::ColorNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a color node
        ///   
        /// The Configuration struct holds the configuration of a color node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param powerLineFrequency the value of the Configuration::powerLineFrequency field
            /// \param compression the value of the Configuration::compression field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::PowerLineFrequency powerLineFrequency, DepthSense::CompressionType compression);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the power line frequency in Hz
            DepthSense::PowerLineFrequency powerLineFrequency;
            /// the compression type
            DepthSense::CompressionType compression;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// Whether to enable the color map
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool enableColorMap;
        #endif
        /// Gets the value of the ColorNode::enableColorMap property
        ///
        /// Gets the value of the ColorNode::enableColorMap property.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the ColorNode::enableColorMap property
        ///
        /// \sa setEnableColorMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableColorMap ();
        /// Sets the value of the ColorNode::enableColorMap property
        ///
        /// Sets the value of the ColorNode::enableColorMap property.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableColorMap(), enableColorMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableColorMap (bool value);
        /// Checks whether property ColorNode::enableColorMap is read-only
        ///
        /// Checks whether property ColorNode::enableColorMap is read-only.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property ColorNode::enableColorMap is read-only
        ///
        /// \sa setEnableColorMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableColorMapIsReadOnly ();
        /// Whether to enable the compressed data
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool enableCompressedData;
        #endif
        /// Gets the value of the ColorNode::enableCompressedData property
        ///
        /// Gets the value of the ColorNode::enableCompressedData property.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the ColorNode::enableCompressedData property
        ///
        /// \sa setEnableCompressedData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableCompressedData ();
        /// Sets the value of the ColorNode::enableCompressedData property
        ///
        /// Sets the value of the ColorNode::enableCompressedData property.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableCompressedData(), enableCompressedDataIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableCompressedData (bool value);
        /// Checks whether property ColorNode::enableCompressedData is read-only
        ///
        /// Checks whether property ColorNode::enableCompressedData is read-only.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property ColorNode::enableCompressedData is read-only
        ///
        /// \sa setEnableCompressedData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableCompressedDataIsReadOnly ();
        /// The node configuration
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ColorNode::Configuration configuration;
        #endif
        /// Gets the value of the ColorNode::configuration property
        ///
        /// Gets the value of the ColorNode::configuration property.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \return the value of the ColorNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::Configuration getConfiguration ();
        /// Sets the value of the ColorNode::configuration property
        ///
        /// Sets the value of the ColorNode::configuration property.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the node no longer exists
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::ColorNode::Configuration value);
        /// Checks whether property ColorNode::configuration is read-only
        ///
        /// Checks whether property ColorNode::configuration is read-only.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \return whether property ColorNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The ColorNode::configurations property specifies the list of
        /// supported node configurations.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::ColorNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::ColorNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the ColorNode::configurations property
        ///
        /// Gets the value of the ColorNode::configurations property.
        ///
        ///
        /// \return the value of the ColorNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::ColorNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::ColorNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The brightness
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t brightness;
        #endif
        /// Gets the value of the ColorNode::brightness property
        ///
        /// Gets the value of the ColorNode::brightness property.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::brightness property
        ///
        /// \sa setBrightness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getBrightness ();
        /// Sets the value of the ColorNode::brightness property
        ///
        /// Sets the value of the ColorNode::brightness property.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getBrightness(), brightnessIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setBrightness (int32_t value);
        /// Checks whether property ColorNode::brightness is read-only
        ///
        /// Checks whether property ColorNode::brightness is read-only.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::brightness is read-only
        ///
        /// \sa setBrightness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool brightnessIsReadOnly ();
        /// The contrast
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t contrast;
        #endif
        /// Gets the value of the ColorNode::contrast property
        ///
        /// Gets the value of the ColorNode::contrast property.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::contrast property
        ///
        /// \sa setContrast()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getContrast ();
        /// Sets the value of the ColorNode::contrast property
        ///
        /// Sets the value of the ColorNode::contrast property.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getContrast(), contrastIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setContrast (int32_t value);
        /// Checks whether property ColorNode::contrast is read-only
        ///
        /// Checks whether property ColorNode::contrast is read-only.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::contrast is read-only
        ///
        /// \sa setContrast()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool contrastIsReadOnly ();
        /// The saturation
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t saturation;
        #endif
        /// Gets the value of the ColorNode::saturation property
        ///
        /// Gets the value of the ColorNode::saturation property.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::saturation property
        ///
        /// \sa setSaturation()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getSaturation ();
        /// Sets the value of the ColorNode::saturation property
        ///
        /// Sets the value of the ColorNode::saturation property.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getSaturation(), saturationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSaturation (int32_t value);
        /// Checks whether property ColorNode::saturation is read-only
        ///
        /// Checks whether property ColorNode::saturation is read-only.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::saturation is read-only
        ///
        /// \sa setSaturation()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool saturationIsReadOnly ();
        /// The hue
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t hue;
        #endif
        /// Gets the value of the ColorNode::hue property
        ///
        /// Gets the value of the ColorNode::hue property.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::hue property
        ///
        /// \sa setHue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHue ();
        /// Sets the value of the ColorNode::hue property
        ///
        /// Sets the value of the ColorNode::hue property.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHue(), hueIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHue (int32_t value);
        /// Checks whether property ColorNode::hue is read-only
        ///
        /// Checks whether property ColorNode::hue is read-only.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::hue is read-only
        ///
        /// \sa setHue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool hueIsReadOnly ();
        /// The gamma
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t gamma;
        #endif
        /// Gets the value of the ColorNode::gamma property
        ///
        /// Gets the value of the ColorNode::gamma property.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::gamma property
        ///
        /// \sa setGamma()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getGamma ();
        /// Sets the value of the ColorNode::gamma property
        ///
        /// Sets the value of the ColorNode::gamma property.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getGamma(), gammaIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGamma (int32_t value);
        /// Checks whether property ColorNode::gamma is read-only
        ///
        /// Checks whether property ColorNode::gamma is read-only.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::gamma is read-only
        ///
        /// \sa setGamma()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gammaIsReadOnly ();
        /// The white balance
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t whiteBalance;
        #endif
        /// Gets the value of the ColorNode::whiteBalance property
        ///
        /// Gets the value of the ColorNode::whiteBalance property.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::whiteBalance property
        ///
        /// \sa setWhiteBalance()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getWhiteBalance ();
        /// Sets the value of the ColorNode::whiteBalance property
        ///
        /// Sets the value of the ColorNode::whiteBalance property.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getWhiteBalance(), whiteBalanceIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setWhiteBalance (int32_t value);
        /// Checks whether property ColorNode::whiteBalance is read-only
        ///
        /// Checks whether property ColorNode::whiteBalance is read-only.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::whiteBalance is read-only
        ///
        /// \sa setWhiteBalance()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool whiteBalanceIsReadOnly ();
        /// The sharpness
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t sharpness;
        #endif
        /// Gets the value of the ColorNode::sharpness property
        ///
        /// Gets the value of the ColorNode::sharpness property.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::sharpness property
        ///
        /// \sa setSharpness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getSharpness ();
        /// Sets the value of the ColorNode::sharpness property
        ///
        /// Sets the value of the ColorNode::sharpness property.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getSharpness(), sharpnessIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSharpness (int32_t value);
        /// Checks whether property ColorNode::sharpness is read-only
        ///
        /// Checks whether property ColorNode::sharpness is read-only.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::sharpness is read-only
        ///
        /// \sa setSharpness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool sharpnessIsReadOnly ();
        /// The gain
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t gain;
        #endif
        /// Gets the value of the ColorNode::gain property
        ///
        /// Gets the value of the ColorNode::gain property.
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::gain property
        ///
        /// \sa setGain()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getGain ();
        /// Sets the value of the ColorNode::gain property
        ///
        /// Sets the value of the ColorNode::gain property.
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getGain(), gainIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGain (int32_t value);
        /// Checks whether property ColorNode::gain is read-only
        ///
        /// Checks whether property ColorNode::gain is read-only.
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::gain is read-only
        ///
        /// \sa setGain()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gainIsReadOnly ();
        /// The exposure (exposure time absolute control).
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t exposure;
        #endif
        /// Gets the value of the ColorNode::exposure property
        ///
        /// Gets the value of the ColorNode::exposure property.
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposure property
        ///
        /// \sa setExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getExposure ();
        /// Sets the value of the ColorNode::exposure property
        ///
        /// Sets the value of the ColorNode::exposure property.
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposure(), exposureIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposure (int32_t value);
        /// Checks whether property ColorNode::exposure is read-only
        ///
        /// Checks whether property ColorNode::exposure is read-only.
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposure is read-only
        ///
        /// \sa setExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureIsReadOnly ();
        /// The auto exposure mode
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ExposureAuto exposureAuto;
        #endif
        /// Gets the value of the ColorNode::exposureAuto property
        ///
        /// Gets the value of the ColorNode::exposureAuto property.
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposureAuto property
        ///
        /// \sa setExposureAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ExposureAuto getExposureAuto ();
        /// Sets the value of the ColorNode::exposureAuto property
        ///
        /// Sets the value of the ColorNode::exposureAuto property.
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposureAuto(), exposureAutoIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposureAuto (DepthSense::ExposureAuto value);
        /// Checks whether property ColorNode::exposureAuto is read-only
        ///
        /// Checks whether property ColorNode::exposureAuto is read-only.
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposureAuto is read-only
        ///
        /// \sa setExposureAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureAutoIsReadOnly ();
        /// Whether to enable the auto exposure priority control
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool exposureAutoPriority;
        #endif
        /// Gets the value of the ColorNode::exposureAutoPriority property
        ///
        /// Gets the value of the ColorNode::exposureAutoPriority property.
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposureAutoPriority property
        ///
        /// \sa setExposureAutoPriority()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getExposureAutoPriority ();
        /// Sets the value of the ColorNode::exposureAutoPriority property
        ///
        /// Sets the value of the ColorNode::exposureAutoPriority property.
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposureAutoPriority(), exposureAutoPriorityIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposureAutoPriority (bool value);
        /// Checks whether property ColorNode::exposureAutoPriority is read-only
        ///
        /// Checks whether property ColorNode::exposureAutoPriority is read-only.
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposureAutoPriority is read-only
        ///
        /// \sa setExposureAutoPriority()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureAutoPriorityIsReadOnly ();
        /// Whether to enable automatic white balance.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool whiteBalanceAuto;
        #endif
        /// Gets the value of the ColorNode::whiteBalanceAuto property
        ///
        /// Gets the value of the ColorNode::whiteBalanceAuto property.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::whiteBalanceAuto property
        ///
        /// \sa setWhiteBalanceAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getWhiteBalanceAuto ();
        /// Sets the value of the ColorNode::whiteBalanceAuto property
        ///
        /// Sets the value of the ColorNode::whiteBalanceAuto property.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getWhiteBalanceAuto(), whiteBalanceAutoIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setWhiteBalanceAuto (bool value);
        /// Checks whether property ColorNode::whiteBalanceAuto is read-only
        ///
        /// Checks whether property ColorNode::whiteBalanceAuto is read-only.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::whiteBalanceAuto is read-only
        ///
        /// \sa setWhiteBalanceAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool whiteBalanceAutoIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::ColorNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::ColorNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
            ::DepthSense::Pointer< uint8_t > colorMap;
            /// The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
            ::DepthSense::Pointer< uint8_t > compressedData;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::ColorNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when a color sample is captured
        ///
        /// The \c newSampleReceived event is raised when a color sample
        /// is captured.
        ///
        /// \param colorMap The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
        /// \param compressedData The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        /// \struct NewSampleReceived2Data DepthSense.hxx
        /// Holds the DepthSense::ColorNode::NewSampleReceived2Event arguments
        ///
        /// The NewSampleReceived2Data struct holds the DepthSense::ColorNode::NewSampleReceived2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceived2Data
        {
            DepthSense::Color::SampleData data;
        };
        /// \class NewSampleReceived2Event DepthSense.hxx
        /// Event raised when a color sample is captured
        ///
        /// The \c newSampleReceived2 event is raised when a color sample
        /// is captured.      
        class NewSampleReceived2Event : public DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>
        {
            private:
            NewSampleReceived2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>(func)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceived2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived2 event object
        ///
        /// Returns a reference to the \c newSampleReceived2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::NewSampleReceived2Event& newSampleReceived2Event () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class BaseValue DepthSense.hxx
    /// The base value class
    ///
    /// Both DepthSense::ParameterValue and DepthSense::RegisterValue derive from this interface
    class BaseValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API BaseValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API BaseValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API BaseValue (const BaseValue& other);
        DEPTHSENSE_API BaseValue& operator= (const BaseValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~BaseValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit BaseValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::GPIOValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::FloatParameterValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::BoolParameterValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::IntParameterValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::RegionOfInterestValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::I2CArrayValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::RegisterValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::SystemInfoValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::SystemCalibrationValue& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::HardwareVersion& iface);
        DEPTHSENSE_API BaseValue (const DepthSense::SystemStateValue& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::BaseValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::BaseValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::BaseValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::BaseValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::BaseValue type object
        ///
        /// Returns the DepthSense::BaseValue type object
        ///
        /// \return the DepthSense::BaseValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class GPIOValue DepthSense.hxx
    /// The gpio class
    ///
    /// This class derives from DepthSense::BaseValue and is used to access GPIOs of the USB backend
    class GPIOValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API GPIOValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API GPIOValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API GPIOValue (const GPIOValue& other);
        DEPTHSENSE_API GPIOValue& operator= (const GPIOValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~GPIOValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit GPIOValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit GPIOValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::GPIOValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::GPIOValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::GPIOValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::GPIOValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::GPIOValue type object
        ///
        /// Returns the DepthSense::GPIOValue type object
        ///
        /// \return the DepthSense::GPIOValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The pin to be controller
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t pin;
        #endif
        /// Gets the value of the GPIOValue::pin property
        ///
        /// Gets the value of the GPIOValue::pin property.
        ///
        ///
        /// \return the value of the GPIOValue::pin property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getPin ();
        /// The state of the pin
        #ifdef DEPTHSENSE_DOC
        @property bool state;
        #endif
        /// Gets the value of the GPIOValue::state property
        ///
        /// Gets the value of the GPIOValue::state property.
        ///
        ///
        /// \return the value of the GPIOValue::state property
        ///
        /// \sa setState()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getState ();
        /// Sets the value of the GPIOValue::state property
        ///
        /// Sets the value of the GPIOValue::state property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getState(), stateIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setState (bool value);
        /// Checks whether property GPIOValue::state is read-only
        ///
        /// Checks whether property GPIOValue::state is read-only.
        ///
        ///
        /// \return whether property GPIOValue::state is read-only
        ///
        /// \sa setState()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool stateIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class FloatParameterValue DepthSense.hxx
    /// The floating point system parameter class 
    ///
    /// This class derives from DepthSense::BaseValue and is used to access system parameters
    /// with a floating point value
    class FloatParameterValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API FloatParameterValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API FloatParameterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API FloatParameterValue (const FloatParameterValue& other);
        DEPTHSENSE_API FloatParameterValue& operator= (const FloatParameterValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~FloatParameterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit FloatParameterValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit FloatParameterValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::FloatParameterValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::FloatParameterValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::FloatParameterValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::FloatParameterValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::FloatParameterValue type object
        ///
        /// Returns the DepthSense::FloatParameterValue type object
        ///
        /// \return the DepthSense::FloatParameterValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The DepthSense::ParameterType of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::ParameterType parameterType;
        #endif
        /// Gets the value of the FloatParameterValue::parameterType property
        ///
        /// Gets the value of the FloatParameterValue::parameterType property.
        ///
        ///
        /// \return the value of the FloatParameterValue::parameterType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ParameterType getParameterType ();
        /// The DepthSense::AccessMode of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::AccessMode accessMode;
        #endif
        /// Gets the value of the FloatParameterValue::accessMode property
        ///
        /// Gets the value of the FloatParameterValue::accessMode property.
        ///
        ///
        /// \return the value of the FloatParameterValue::accessMode property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AccessMode getAccessMode ();
        /// The DepthSense::UnitType of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::UnitType unitType;
        #endif
        /// Gets the value of the FloatParameterValue::unitType property
        ///
        /// Gets the value of the FloatParameterValue::unitType property.
        ///
        ///
        /// \return the value of the FloatParameterValue::unitType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::UnitType getUnitType ();
        /// The value of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property float value;
        #endif
        /// Gets the value of the FloatParameterValue::value property
        ///
        /// Gets the value of the FloatParameterValue::value property.
        ///
        ///
        /// \return the value of the FloatParameterValue::value property
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getValue ();
        /// Sets the value of the FloatParameterValue::value property
        ///
        /// Sets the value of the FloatParameterValue::value property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValue(), valueIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setValue (float value);
        /// Checks whether property FloatParameterValue::value is read-only
        ///
        /// Checks whether property FloatParameterValue::value is read-only.
        ///
        ///
        /// \return whether property FloatParameterValue::value is read-only
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class BoolParameterValue DepthSense.hxx
    /// The boolean system parameter class 
    ///
    /// This class derives from DepthSense::BaseValue and is used to access system parameters
    /// with a boolean value
    class BoolParameterValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API BoolParameterValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API BoolParameterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API BoolParameterValue (const BoolParameterValue& other);
        DEPTHSENSE_API BoolParameterValue& operator= (const BoolParameterValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~BoolParameterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit BoolParameterValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit BoolParameterValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::BoolParameterValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::BoolParameterValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::BoolParameterValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::BoolParameterValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::BoolParameterValue type object
        ///
        /// Returns the DepthSense::BoolParameterValue type object
        ///
        /// \return the DepthSense::BoolParameterValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The DepthSense::ParameterType of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::ParameterType parameterType;
        #endif
        /// Gets the value of the BoolParameterValue::parameterType property
        ///
        /// Gets the value of the BoolParameterValue::parameterType property.
        ///
        ///
        /// \return the value of the BoolParameterValue::parameterType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ParameterType getParameterType ();
        /// The DepthSense::AccessMode of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::AccessMode accessMode;
        #endif
        /// Gets the value of the BoolParameterValue::accessMode property
        ///
        /// Gets the value of the BoolParameterValue::accessMode property.
        ///
        ///
        /// \return the value of the BoolParameterValue::accessMode property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AccessMode getAccessMode ();
        /// The value of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property bool value;
        #endif
        /// Gets the value of the BoolParameterValue::value property
        ///
        /// Gets the value of the BoolParameterValue::value property.
        ///
        ///
        /// \return the value of the BoolParameterValue::value property
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getValue ();
        /// Sets the value of the BoolParameterValue::value property
        ///
        /// Sets the value of the BoolParameterValue::value property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValue(), valueIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setValue (bool value);
        /// Checks whether property BoolParameterValue::value is read-only
        ///
        /// Checks whether property BoolParameterValue::value is read-only.
        ///
        ///
        /// \return whether property BoolParameterValue::value is read-only
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class IntParameterValue DepthSense.hxx
    /// The integer system parameter class 
    ///
    /// This class derives from DepthSense::BaseValue and is used to access system parameters
    /// with an integer value
    class IntParameterValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API IntParameterValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API IntParameterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API IntParameterValue (const IntParameterValue& other);
        DEPTHSENSE_API IntParameterValue& operator= (const IntParameterValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~IntParameterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit IntParameterValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit IntParameterValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::IntParameterValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::IntParameterValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::IntParameterValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::IntParameterValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::IntParameterValue type object
        ///
        /// Returns the DepthSense::IntParameterValue type object
        ///
        /// \return the DepthSense::IntParameterValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The DepthSense::ParameterType of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::ParameterType parameterType;
        #endif
        /// Gets the value of the IntParameterValue::parameterType property
        ///
        /// Gets the value of the IntParameterValue::parameterType property.
        ///
        ///
        /// \return the value of the IntParameterValue::parameterType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ParameterType getParameterType ();
        /// The DepthSense::AccessMode of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::AccessMode accessMode;
        #endif
        /// Gets the value of the IntParameterValue::accessMode property
        ///
        /// Gets the value of the IntParameterValue::accessMode property.
        ///
        ///
        /// \return the value of the IntParameterValue::accessMode property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AccessMode getAccessMode ();
        /// The value of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property int32_t value;
        #endif
        /// Gets the value of the IntParameterValue::value property
        ///
        /// Gets the value of the IntParameterValue::value property.
        ///
        ///
        /// \return the value of the IntParameterValue::value property
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getValue ();
        /// Sets the value of the IntParameterValue::value property
        ///
        /// Sets the value of the IntParameterValue::value property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValue(), valueIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setValue (int32_t value);
        /// Checks whether property IntParameterValue::value is read-only
        ///
        /// Checks whether property IntParameterValue::value is read-only.
        ///
        ///
        /// \return whether property IntParameterValue::value is read-only
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class RegionOfInterestValue DepthSense.hxx
    /// The RegionOfInterest class
    ///
    /// This class derives from DepthSense::BaseValue and is used to access the region of interest
    class RegionOfInterestValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API RegionOfInterestValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API RegionOfInterestValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API RegionOfInterestValue (const RegionOfInterestValue& other);
        DEPTHSENSE_API RegionOfInterestValue& operator= (const RegionOfInterestValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~RegionOfInterestValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit RegionOfInterestValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit RegionOfInterestValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::RegionOfInterestValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::RegionOfInterestValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::RegionOfInterestValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::RegionOfInterestValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::RegionOfInterestValue type object
        ///
        /// Returns the DepthSense::RegionOfInterestValue type object
        ///
        /// \return the DepthSense::RegionOfInterestValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The DepthSense::AccessMode of the system parameter
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::AccessMode accessMode;
        #endif
        /// Gets the value of the RegionOfInterestValue::accessMode property
        ///
        /// Gets the value of the RegionOfInterestValue::accessMode property.
        ///
        ///
        /// \return the value of the RegionOfInterestValue::accessMode property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AccessMode getAccessMode ();
        /// The Region of interest
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::RegionOfInterest value;
        #endif
        /// Gets the value of the RegionOfInterestValue::value property
        ///
        /// Gets the value of the RegionOfInterestValue::value property.
        ///
        ///
        /// \return the value of the RegionOfInterestValue::value property
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::RegionOfInterest getValue ();
        /// Sets the value of the RegionOfInterestValue::value property
        ///
        /// Sets the value of the RegionOfInterestValue::value property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValue(), valueIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setValue (DepthSense::RegionOfInterest value);
        /// Checks whether property RegionOfInterestValue::value is read-only
        ///
        /// Checks whether property RegionOfInterestValue::value is read-only.
        ///
        ///
        /// \return whether property RegionOfInterestValue::value is read-only
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class I2CArrayValue DepthSense.hxx
    /// The i2c array class
    ///
    /// This clas derives from DepthSense::BaseValue and is used to send or receive an arbitrary length of bytes
    class I2CArrayValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API I2CArrayValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API I2CArrayValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API I2CArrayValue (const I2CArrayValue& other);
        DEPTHSENSE_API I2CArrayValue& operator= (const I2CArrayValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~I2CArrayValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit I2CArrayValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit I2CArrayValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::I2CArrayValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::I2CArrayValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::I2CArrayValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::I2CArrayValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::I2CArrayValue type object
        ///
        /// Returns the DepthSense::I2CArrayValue type object
        ///
        /// \return the DepthSense::I2CArrayValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The 7 bits address of the device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t i2cAddress;
        #endif
        /// Gets the value of the I2CArrayValue::i2cAddress property
        ///
        /// Gets the value of the I2CArrayValue::i2cAddress property.
        ///
        ///
        /// \return the value of the I2CArrayValue::i2cAddress property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getI2cAddress ();
        /// The array of ubyte
        #ifdef DEPTHSENSE_DOC
        @property std::vector< uint8_t > value;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< uint8_t > _p_getValue ();
        public:
        /// Gets the value of the I2CArrayValue::value property
        ///
        /// Gets the value of the I2CArrayValue::value property.
        ///
        ///
        /// \return the value of the I2CArrayValue::value property
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< uint8_t > getValue ()
        {
            std::vector< uint8_t > retval = _p_getValue().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setValue (::DSI::Vector< uint8_t > value);
        public:
        /// Sets the value of the I2CArrayValue::value property
        ///
        /// Sets the value of the I2CArrayValue::value property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValue(), valueIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setValue (std::vector< uint8_t > value)
        {
            ::DSI::Vector< uint8_t > _p_value = DSI::Vector< uint8_t >::marshal(value);
            _p_setValue(_p_value);
        }
        /// Checks whether property I2CArrayValue::value is read-only
        ///
        /// Checks whether property I2CArrayValue::value is read-only.
        ///
        ///
        /// \return whether property I2CArrayValue::value is read-only
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class RegisterValue DepthSense.hxx
    /// The register class
    ///
    /// This class derives from DepthSense::BaseValue and is used to access registers of an i2c device
    class RegisterValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API RegisterValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API RegisterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API RegisterValue (const RegisterValue& other);
        DEPTHSENSE_API RegisterValue& operator= (const RegisterValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~RegisterValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit RegisterValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit RegisterValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::RegisterValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::RegisterValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::RegisterValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::RegisterValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::RegisterValue type object
        ///
        /// Returns the DepthSense::RegisterValue type object
        ///
        /// \return the DepthSense::RegisterValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The 7 bits address of the device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t i2cAddress;
        #endif
        /// Gets the value of the RegisterValue::i2cAddress property
        ///
        /// Gets the value of the RegisterValue::i2cAddress property.
        ///
        ///
        /// \return the value of the RegisterValue::i2cAddress property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getI2cAddress ();
        /// The value of the register
        #ifdef DEPTHSENSE_DOC
        @property uint32_t value;
        #endif
        /// Gets the value of the RegisterValue::value property
        ///
        /// Gets the value of the RegisterValue::value property.
        ///
        ///
        /// \return the value of the RegisterValue::value property
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getValue ();
        /// Sets the value of the RegisterValue::value property
        ///
        /// Sets the value of the RegisterValue::value property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValue(), valueIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setValue (uint32_t value);
        /// Checks whether property RegisterValue::value is read-only
        ///
        /// Checks whether property RegisterValue::value is read-only.
        ///
        ///
        /// \return whether property RegisterValue::value is read-only
        ///
        /// \sa setValue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueIsReadOnly ();
        /// The register address
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t address;
        #endif
        /// Gets the value of the RegisterValue::address property
        ///
        /// Gets the value of the RegisterValue::address property.
        ///
        ///
        /// \return the value of the RegisterValue::address property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getAddress ();
        /// The length of the register address (must be 1 or 2)
        #ifdef DEPTHSENSE_DOC
        @property uint32_t addressLength;
        #endif
        /// Gets the value of the RegisterValue::addressLength property
        ///
        /// Gets the value of the RegisterValue::addressLength property.
        ///
        ///
        /// \return the value of the RegisterValue::addressLength property
        ///
        /// \sa setAddressLength()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getAddressLength ();
        /// Sets the value of the RegisterValue::addressLength property
        ///
        /// Sets the value of the RegisterValue::addressLength property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getAddressLength(), addressLengthIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setAddressLength (uint32_t value);
        /// Checks whether property RegisterValue::addressLength is read-only
        ///
        /// Checks whether property RegisterValue::addressLength is read-only.
        ///
        ///
        /// \return whether property RegisterValue::addressLength is read-only
        ///
        /// \sa setAddressLength()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool addressLengthIsReadOnly ();
        /// The length of the register value (must be 1 or 2)
        #ifdef DEPTHSENSE_DOC
        @property uint32_t valueLength;
        #endif
        /// Gets the value of the RegisterValue::valueLength property
        ///
        /// Gets the value of the RegisterValue::valueLength property.
        ///
        ///
        /// \return the value of the RegisterValue::valueLength property
        ///
        /// \sa setValueLength()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getValueLength ();
        /// Sets the value of the RegisterValue::valueLength property
        ///
        /// Sets the value of the RegisterValue::valueLength property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getValueLength(), valueLengthIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setValueLength (uint32_t value);
        /// Checks whether property RegisterValue::valueLength is read-only
        ///
        /// Checks whether property RegisterValue::valueLength is read-only.
        ///
        ///
        /// \return whether property RegisterValue::valueLength is read-only
        ///
        /// \sa setValueLength()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool valueLengthIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class SystemInfoValue DepthSense.hxx
    /// The system info class
    ///
    /// This class derives from DepthSense::BaseValue and is used to access the system info.
    class SystemInfoValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API SystemInfoValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API SystemInfoValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API SystemInfoValue (const SystemInfoValue& other);
        DEPTHSENSE_API SystemInfoValue& operator= (const SystemInfoValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~SystemInfoValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit SystemInfoValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit SystemInfoValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::SystemInfoValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::SystemInfoValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::SystemInfoValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::SystemInfoValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::SystemInfoValue type object
        ///
        /// Returns the DepthSense::SystemInfoValue type object
        ///
        /// \return the DepthSense::SystemInfoValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// Whether the prv number of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool prvNumberLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::prvNumberLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::prvNumberLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::prvNumberLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getPrvNumberLoadedFromDevice ();
        /// The prv number of the camera
        #ifdef DEPTHSENSE_DOC
        @property uint32_t prvNumber;
        #endif
        /// Gets the value of the SystemInfoValue::prvNumber property
        ///
        /// Gets the value of the SystemInfoValue::prvNumber property.
        ///
        ///
        /// \return the value of the SystemInfoValue::prvNumber property
        ///
        /// \sa setPrvNumber()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getPrvNumber ();
        /// Sets the value of the SystemInfoValue::prvNumber property
        ///
        /// Sets the value of the SystemInfoValue::prvNumber property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getPrvNumber(), prvNumberIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setPrvNumber (uint32_t value);
        /// Checks whether property SystemInfoValue::prvNumber is read-only
        ///
        /// Checks whether property SystemInfoValue::prvNumber is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::prvNumber is read-only
        ///
        /// \sa setPrvNumber()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool prvNumberIsReadOnly ();
        /// Whether the production ID of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool productionIDLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::productionIDLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::productionIDLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::productionIDLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getProductionIDLoadedFromDevice ();
        /// The production ID of the camera
        #ifdef DEPTHSENSE_DOC
        @property std::string productionID;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getProductionID ();
        public:
        /// Gets the value of the SystemInfoValue::productionID property
        ///
        /// Gets the value of the SystemInfoValue::productionID property.
        ///
        ///
        /// \return the value of the SystemInfoValue::productionID property
        ///
        /// \sa setProductionID()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getProductionID ()
        {
            std::string retval = _p_getProductionID().unmarshal();
            return retval;
        }
        /// Sets the value of the SystemInfoValue::productionID property
        ///
        /// Sets the value of the SystemInfoValue::productionID property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getProductionID(), productionIDIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setProductionID (const char* value);
        /// Checks whether property SystemInfoValue::productionID is read-only
        ///
        /// Checks whether property SystemInfoValue::productionID is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::productionID is read-only
        ///
        /// \sa setProductionID()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool productionIDIsReadOnly ();
        /// Whether the calibration tool string of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool calibrationToolStringLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::calibrationToolStringLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::calibrationToolStringLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::calibrationToolStringLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getCalibrationToolStringLoadedFromDevice ();
        /// The calibration tool string
        #ifdef DEPTHSENSE_DOC
        @property std::string calibrationToolString;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getCalibrationToolString ();
        public:
        /// Gets the value of the SystemInfoValue::calibrationToolString property
        ///
        /// Gets the value of the SystemInfoValue::calibrationToolString property.
        ///
        ///
        /// \return the value of the SystemInfoValue::calibrationToolString property
        ///
        /// \sa setCalibrationToolString()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getCalibrationToolString ()
        {
            std::string retval = _p_getCalibrationToolString().unmarshal();
            return retval;
        }
        /// Sets the value of the SystemInfoValue::calibrationToolString property
        ///
        /// Sets the value of the SystemInfoValue::calibrationToolString property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getCalibrationToolString(), calibrationToolStringIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCalibrationToolString (const char* value);
        /// Checks whether property SystemInfoValue::calibrationToolString is read-only
        ///
        /// Checks whether property SystemInfoValue::calibrationToolString is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::calibrationToolString is read-only
        ///
        /// \sa setCalibrationToolString()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool calibrationToolStringIsReadOnly ();
        /// Whether the calibration tool timestamp of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool calibrationTimestampLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::calibrationTimestampLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::calibrationTimestampLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::calibrationTimestampLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getCalibrationTimestampLoadedFromDevice ();
        /// The calibration timestamp
        #ifdef DEPTHSENSE_DOC
        @property uint32_t calibrationTimestamp;
        #endif
        /// Gets the value of the SystemInfoValue::calibrationTimestamp property
        ///
        /// Gets the value of the SystemInfoValue::calibrationTimestamp property.
        ///
        ///
        /// \return the value of the SystemInfoValue::calibrationTimestamp property
        ///
        /// \sa setCalibrationTimestamp()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getCalibrationTimestamp ();
        /// Sets the value of the SystemInfoValue::calibrationTimestamp property
        ///
        /// Sets the value of the SystemInfoValue::calibrationTimestamp property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getCalibrationTimestamp(), calibrationTimestampIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCalibrationTimestamp (uint32_t value);
        /// Checks whether property SystemInfoValue::calibrationTimestamp is read-only
        ///
        /// Checks whether property SystemInfoValue::calibrationTimestamp is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::calibrationTimestamp is read-only
        ///
        /// \sa setCalibrationTimestamp()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool calibrationTimestampIsReadOnly ();
        /// Whether the lens type of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool lensTypeLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::lensTypeLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::lensTypeLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::lensTypeLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getLensTypeLoadedFromDevice ();
        /// The lens type
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::LensType lensType;
        #endif
        /// Gets the value of the SystemInfoValue::lensType property
        ///
        /// Gets the value of the SystemInfoValue::lensType property.
        ///
        ///
        /// \return the value of the SystemInfoValue::lensType property
        ///
        /// \sa setLensType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::LensType getLensType ();
        /// Sets the value of the SystemInfoValue::lensType property
        ///
        /// Sets the value of the SystemInfoValue::lensType property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getLensType(), lensTypeIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setLensType (DepthSense::LensType value);
        /// Checks whether property SystemInfoValue::lensType is read-only
        ///
        /// Checks whether property SystemInfoValue::lensType is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::lensType is read-only
        ///
        /// \sa setLensType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool lensTypeIsReadOnly ();
        /// Whether the sensor type of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool depthSensorTypeLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::depthSensorTypeLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::depthSensorTypeLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::depthSensorTypeLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthSensorTypeLoadedFromDevice ();
        /// The sensor type
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::DepthSensorType depthSensorType;
        #endif
        /// Gets the value of the SystemInfoValue::depthSensorType property
        ///
        /// Gets the value of the SystemInfoValue::depthSensorType property.
        ///
        ///
        /// \return the value of the SystemInfoValue::depthSensorType property
        ///
        /// \sa setDepthSensorType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthSensorType getDepthSensorType ();
        /// Sets the value of the SystemInfoValue::depthSensorType property
        ///
        /// Sets the value of the SystemInfoValue::depthSensorType property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthSensorType(), depthSensorTypeIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthSensorType (DepthSense::DepthSensorType value);
        /// Checks whether property SystemInfoValue::depthSensorType is read-only
        ///
        /// Checks whether property SystemInfoValue::depthSensorType is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::depthSensorType is read-only
        ///
        /// \sa setDepthSensorType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthSensorTypeIsReadOnly ();
        /// Whether the illumination type of the camera was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool illuminationTypeLoadedFromDevice;
        #endif
        /// Gets the value of the SystemInfoValue::illuminationTypeLoadedFromDevice property
        ///
        /// Gets the value of the SystemInfoValue::illuminationTypeLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemInfoValue::illuminationTypeLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getIlluminationTypeLoadedFromDevice ();
        /// The illumination type
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::IlluminationType illuminationType;
        #endif
        /// Gets the value of the SystemInfoValue::illuminationType property
        ///
        /// Gets the value of the SystemInfoValue::illuminationType property.
        ///
        ///
        /// \return the value of the SystemInfoValue::illuminationType property
        ///
        /// \sa setIlluminationType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::IlluminationType getIlluminationType ();
        /// Sets the value of the SystemInfoValue::illuminationType property
        ///
        /// Sets the value of the SystemInfoValue::illuminationType property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getIlluminationType(), illuminationTypeIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setIlluminationType (DepthSense::IlluminationType value);
        /// Checks whether property SystemInfoValue::illuminationType is read-only
        ///
        /// Checks whether property SystemInfoValue::illuminationType is read-only.
        ///
        ///
        /// \return whether property SystemInfoValue::illuminationType is read-only
        ///
        /// \sa setIlluminationType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool illuminationTypeIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class SystemCalibrationValue DepthSense.hxx
    /// The system calibration class
    ///
    /// This class derives from DepthSense::BaseValue and is used to access the system calibration.
    class SystemCalibrationValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API SystemCalibrationValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API SystemCalibrationValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API SystemCalibrationValue (const SystemCalibrationValue& other);
        DEPTHSENSE_API SystemCalibrationValue& operator= (const SystemCalibrationValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~SystemCalibrationValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit SystemCalibrationValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit SystemCalibrationValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::SystemCalibrationValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::SystemCalibrationValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::SystemCalibrationValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::SystemCalibrationValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::SystemCalibrationValue type object
        ///
        /// Returns the DepthSense::SystemCalibrationValue type object
        ///
        /// \return the DepthSense::SystemCalibrationValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// Whether the set of depth intrinsics of the SystemCalibrationValue were loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool depthIntrinsicsLoadedFromDevice;
        #endif
        /// Gets the value of the SystemCalibrationValue::depthIntrinsicsLoadedFromDevice property
        ///
        /// Gets the value of the SystemCalibrationValue::depthIntrinsicsLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemCalibrationValue::depthIntrinsicsLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthIntrinsicsLoadedFromDevice ();
        /// The set of intrinsic parameters of the depth lens
        #ifdef DEPTHSENSE_DOC
        @property std::vector< DepthSense::IntrinsicParameters > depthIntrinsics;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::IntrinsicParameters > _p_getDepthIntrinsics ();
        public:
        /// Gets the value of the SystemCalibrationValue::depthIntrinsics property
        ///
        /// Gets the value of the SystemCalibrationValue::depthIntrinsics property.
        ///
        ///
        /// \return the value of the SystemCalibrationValue::depthIntrinsics property
        ///
        /// \sa setDepthIntrinsics()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::IntrinsicParameters > getDepthIntrinsics ()
        {
            std::vector< DepthSense::IntrinsicParameters > retval = _p_getDepthIntrinsics().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setDepthIntrinsics (::DSI::Vector< DepthSense::IntrinsicParameters > value);
        public:
        /// Sets the value of the SystemCalibrationValue::depthIntrinsics property
        ///
        /// Sets the value of the SystemCalibrationValue::depthIntrinsics property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthIntrinsics(), depthIntrinsicsIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setDepthIntrinsics (std::vector< DepthSense::IntrinsicParameters > value)
        {
            ::DSI::Vector< DepthSense::IntrinsicParameters > _p_value = DSI::Vector< DepthSense::IntrinsicParameters >::marshal(value);
            _p_setDepthIntrinsics(_p_value);
        }
        /// Checks whether property SystemCalibrationValue::depthIntrinsics is read-only
        ///
        /// Checks whether property SystemCalibrationValue::depthIntrinsics is read-only.
        ///
        ///
        /// \return whether property SystemCalibrationValue::depthIntrinsics is read-only
        ///
        /// \sa setDepthIntrinsics()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthIntrinsicsIsReadOnly ();
        /// Whether the set of color intrinsics of the SystemCalibrationValue were loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool colorIntrinsicsLoadedFromDevice;
        #endif
        /// Gets the value of the SystemCalibrationValue::colorIntrinsicsLoadedFromDevice property
        ///
        /// Gets the value of the SystemCalibrationValue::colorIntrinsicsLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemCalibrationValue::colorIntrinsicsLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getColorIntrinsicsLoadedFromDevice ();
        /// The set of intrinsic parameters of the color lens
        #ifdef DEPTHSENSE_DOC
        @property std::vector< DepthSense::IntrinsicParameters > colorIntrinsics;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::IntrinsicParameters > _p_getColorIntrinsics ();
        public:
        /// Gets the value of the SystemCalibrationValue::colorIntrinsics property
        ///
        /// Gets the value of the SystemCalibrationValue::colorIntrinsics property.
        ///
        ///
        /// \return the value of the SystemCalibrationValue::colorIntrinsics property
        ///
        /// \sa setColorIntrinsics()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::IntrinsicParameters > getColorIntrinsics ()
        {
            std::vector< DepthSense::IntrinsicParameters > retval = _p_getColorIntrinsics().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setColorIntrinsics (::DSI::Vector< DepthSense::IntrinsicParameters > value);
        public:
        /// Sets the value of the SystemCalibrationValue::colorIntrinsics property
        ///
        /// Sets the value of the SystemCalibrationValue::colorIntrinsics property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getColorIntrinsics(), colorIntrinsicsIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setColorIntrinsics (std::vector< DepthSense::IntrinsicParameters > value)
        {
            ::DSI::Vector< DepthSense::IntrinsicParameters > _p_value = DSI::Vector< DepthSense::IntrinsicParameters >::marshal(value);
            _p_setColorIntrinsics(_p_value);
        }
        /// Checks whether property SystemCalibrationValue::colorIntrinsics is read-only
        ///
        /// Checks whether property SystemCalibrationValue::colorIntrinsics is read-only.
        ///
        ///
        /// \return whether property SystemCalibrationValue::colorIntrinsics is read-only
        ///
        /// \sa setColorIntrinsics()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool colorIntrinsicsIsReadOnly ();
        /// Whether the extrinsics of the SystemCalibrationValue were loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool extrinsicsLoadedFromDevice;
        #endif
        /// Gets the value of the SystemCalibrationValue::extrinsicsLoadedFromDevice property
        ///
        /// Gets the value of the SystemCalibrationValue::extrinsicsLoadedFromDevice property.
        ///
        ///
        /// \return the value of the SystemCalibrationValue::extrinsicsLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getExtrinsicsLoadedFromDevice ();
        /// The extrinsic parameters of the device. The coordinate system used 
        /// for the extrinsics is the one specified through \c coordinateSystemType property.
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ExtrinsicParameters extrinsics;
        #endif
        /// Gets the value of the SystemCalibrationValue::extrinsics property
        ///
        /// Gets the value of the SystemCalibrationValue::extrinsics property.
        ///
        ///
        /// \return the value of the SystemCalibrationValue::extrinsics property
        ///
        /// \sa setExtrinsics()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ExtrinsicParameters getExtrinsics ();
        /// Sets the value of the SystemCalibrationValue::extrinsics property
        ///
        /// Sets the value of the SystemCalibrationValue::extrinsics property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getExtrinsics(), extrinsicsIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExtrinsics (DepthSense::ExtrinsicParameters value);
        /// Checks whether property SystemCalibrationValue::extrinsics is read-only
        ///
        /// Checks whether property SystemCalibrationValue::extrinsics is read-only.
        ///
        ///
        /// \return whether property SystemCalibrationValue::extrinsics is read-only
        ///
        /// \sa setExtrinsics()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool extrinsicsIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class TemperatureCorrection DepthSense.hxx
    /// The TemperatureCorrection class
    ///
    /// This class holds the data related to the Temperature Correction of the depth map
    class TemperatureCorrection
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API TemperatureCorrection (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API TemperatureCorrection ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API TemperatureCorrection (const TemperatureCorrection& other);
        DEPTHSENSE_API TemperatureCorrection& operator= (const TemperatureCorrection& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~TemperatureCorrection ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit TemperatureCorrection (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::TemperatureCorrection& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::TemperatureCorrection& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::TemperatureCorrection& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::TemperatureCorrection& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::TemperatureCorrection type object
        ///
        /// Returns the DepthSense::TemperatureCorrection type object
        ///
        /// \return the DepthSense::TemperatureCorrection type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The algorithm to be used
        ///
        /// The correction applied to the phase map
        /// is the linear combination of the difference between the measured temperature and the
        /// reference temperature.
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::TemperatureCorrectionAlgorithm algorithm;
        #endif
        /// Gets the value of the TemperatureCorrection::algorithm property
        ///
        /// Gets the value of the TemperatureCorrection::algorithm property.
        ///
        /// The correction applied to the phase map
        /// is the linear combination of the difference between the measured temperature and the
        /// reference temperature.
        ///
        /// \return the value of the TemperatureCorrection::algorithm property
        ///
        /// \sa setAlgorithm()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::TemperatureCorrectionAlgorithm getAlgorithm ();
        /// Sets the value of the TemperatureCorrection::algorithm property
        ///
        /// Sets the value of the TemperatureCorrection::algorithm property.
        ///
        /// The correction applied to the phase map
        /// is the linear combination of the difference between the measured temperature and the
        /// reference temperature.
        ///
        /// \param value the value to set
        ///
        /// \sa getAlgorithm(), algorithmIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setAlgorithm (DepthSense::TemperatureCorrectionAlgorithm value);
        /// Checks whether property TemperatureCorrection::algorithm is read-only
        ///
        /// Checks whether property TemperatureCorrection::algorithm is read-only.
        ///
        /// The correction applied to the phase map
        /// is the linear combination of the difference between the measured temperature and the
        /// reference temperature.
        ///
        /// \return whether property TemperatureCorrection::algorithm is read-only
        ///
        /// \sa setAlgorithm()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool algorithmIsReadOnly ();
        /// The temperature of each sensors at the time of calibration in Celsius
        ///
        /// For the TI-CDK, the first temperature in the vector must be the illumination temperature while
        /// the second is the sensor temperature.
        #ifdef DEPTHSENSE_DOC
        @property std::vector< float > referenceTemperatures;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< float > _p_getReferenceTemperatures ();
        public:
        /// Gets the value of the TemperatureCorrection::referenceTemperatures property
        ///
        /// Gets the value of the TemperatureCorrection::referenceTemperatures property.
        ///
        /// For the TI-CDK, the first temperature in the vector must be the illumination temperature while
        /// the second is the sensor temperature.
        ///
        /// \return the value of the TemperatureCorrection::referenceTemperatures property
        ///
        /// \sa setReferenceTemperatures()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< float > getReferenceTemperatures ()
        {
            std::vector< float > retval = _p_getReferenceTemperatures().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setReferenceTemperatures (::DSI::Vector< float > value);
        public:
        /// Sets the value of the TemperatureCorrection::referenceTemperatures property
        ///
        /// Sets the value of the TemperatureCorrection::referenceTemperatures property.
        ///
        /// For the TI-CDK, the first temperature in the vector must be the illumination temperature while
        /// the second is the sensor temperature.
        ///
        /// \param value the value to set
        ///
        /// \sa getReferenceTemperatures(), referenceTemperaturesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setReferenceTemperatures (std::vector< float > value)
        {
            ::DSI::Vector< float > _p_value = DSI::Vector< float >::marshal(value);
            _p_setReferenceTemperatures(_p_value);
        }
        /// Checks whether property TemperatureCorrection::referenceTemperatures is read-only
        ///
        /// Checks whether property TemperatureCorrection::referenceTemperatures is read-only.
        ///
        /// For the TI-CDK, the first temperature in the vector must be the illumination temperature while
        /// the second is the sensor temperature.
        ///
        /// \return whether property TemperatureCorrection::referenceTemperatures is read-only
        ///
        /// \sa setReferenceTemperatures()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool referenceTemperaturesIsReadOnly ();
        /// The coefficient to apply for each temperature
        ///
        /// The coefficients are expressed in phase unit per Celsius.
        /// For the TI-CDK, the first coefficient in the vector must be the illumination coefficient while
        /// the second is the sensor coefficient.
        #ifdef DEPTHSENSE_DOC
        @property std::vector< float > coefficients;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< float > _p_getCoefficients ();
        public:
        /// Gets the value of the TemperatureCorrection::coefficients property
        ///
        /// Gets the value of the TemperatureCorrection::coefficients property.
        ///
        /// The coefficients are expressed in phase unit per Celsius.
        /// For the TI-CDK, the first coefficient in the vector must be the illumination coefficient while
        /// the second is the sensor coefficient.
        ///
        /// \return the value of the TemperatureCorrection::coefficients property
        ///
        /// \sa setCoefficients()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< float > getCoefficients ()
        {
            std::vector< float > retval = _p_getCoefficients().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setCoefficients (::DSI::Vector< float > value);
        public:
        /// Sets the value of the TemperatureCorrection::coefficients property
        ///
        /// Sets the value of the TemperatureCorrection::coefficients property.
        ///
        /// The coefficients are expressed in phase unit per Celsius.
        /// For the TI-CDK, the first coefficient in the vector must be the illumination coefficient while
        /// the second is the sensor coefficient.
        ///
        /// \param value the value to set
        ///
        /// \sa getCoefficients(), coefficientsIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setCoefficients (std::vector< float > value)
        {
            ::DSI::Vector< float > _p_value = DSI::Vector< float >::marshal(value);
            _p_setCoefficients(_p_value);
        }
        /// Checks whether property TemperatureCorrection::coefficients is read-only
        ///
        /// Checks whether property TemperatureCorrection::coefficients is read-only.
        ///
        /// The coefficients are expressed in phase unit per Celsius.
        /// For the TI-CDK, the first coefficient in the vector must be the illumination coefficient while
        /// the second is the sensor coefficient.
        ///
        /// \return whether property TemperatureCorrection::coefficients is read-only
        ///
        /// \sa setCoefficients()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool coefficientsIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class CyclicErrorCorrection DepthSense.hxx
    /// The CyclicErrorCorrection class
    ///
    /// This class holds the data related to the Cyclic Error Correction of the depth map
    class CyclicErrorCorrection
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API CyclicErrorCorrection (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API CyclicErrorCorrection ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API CyclicErrorCorrection (const CyclicErrorCorrection& other);
        DEPTHSENSE_API CyclicErrorCorrection& operator= (const CyclicErrorCorrection& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~CyclicErrorCorrection ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit CyclicErrorCorrection (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::CyclicErrorCorrection& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::CyclicErrorCorrection& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::CyclicErrorCorrection& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::CyclicErrorCorrection& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::CyclicErrorCorrection type object
        ///
        /// Returns the DepthSense::CyclicErrorCorrection type object
        ///
        /// \return the DepthSense::CyclicErrorCorrection type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The algorithm to be used
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::CyclicErrorCorrectionAlgorithm algorithm;
        #endif
        /// Gets the value of the CyclicErrorCorrection::algorithm property
        ///
        /// Gets the value of the CyclicErrorCorrection::algorithm property.
        ///
        ///
        /// \return the value of the CyclicErrorCorrection::algorithm property
        ///
        /// \sa setAlgorithm()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::CyclicErrorCorrectionAlgorithm getAlgorithm ();
        /// Sets the value of the CyclicErrorCorrection::algorithm property
        ///
        /// Sets the value of the CyclicErrorCorrection::algorithm property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getAlgorithm(), algorithmIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setAlgorithm (DepthSense::CyclicErrorCorrectionAlgorithm value);
        /// Checks whether property CyclicErrorCorrection::algorithm is read-only
        ///
        /// Checks whether property CyclicErrorCorrection::algorithm is read-only.
        ///
        ///
        /// \return whether property CyclicErrorCorrection::algorithm is read-only
        ///
        /// \sa setAlgorithm()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool algorithmIsReadOnly ();
        /// The coefficient to be used in the cyclic error correction algorithm
        #ifdef DEPTHSENSE_DOC
        @property std::vector< float > coefficients;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< float > _p_getCoefficients ();
        public:
        /// Gets the value of the CyclicErrorCorrection::coefficients property
        ///
        /// Gets the value of the CyclicErrorCorrection::coefficients property.
        ///
        ///
        /// \return the value of the CyclicErrorCorrection::coefficients property
        ///
        /// \sa setCoefficients()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< float > getCoefficients ()
        {
            std::vector< float > retval = _p_getCoefficients().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setCoefficients (::DSI::Vector< float > value);
        public:
        /// Sets the value of the CyclicErrorCorrection::coefficients property
        ///
        /// Sets the value of the CyclicErrorCorrection::coefficients property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getCoefficients(), coefficientsIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setCoefficients (std::vector< float > value)
        {
            ::DSI::Vector< float > _p_value = DSI::Vector< float >::marshal(value);
            _p_setCoefficients(_p_value);
        }
        /// Checks whether property CyclicErrorCorrection::coefficients is read-only
        ///
        /// Checks whether property CyclicErrorCorrection::coefficients is read-only.
        ///
        ///
        /// \return whether property CyclicErrorCorrection::coefficients is read-only
        ///
        /// \sa setCoefficients()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool coefficientsIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class GradientDistortionCorrection DepthSense.hxx
    /// The Gradient Distortion Correction class
    ///
    /// This class holds the data related to the gradient distortion correction of the depth map
    class GradientDistortionCorrection
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API GradientDistortionCorrection (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API GradientDistortionCorrection ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API GradientDistortionCorrection (const GradientDistortionCorrection& other);
        DEPTHSENSE_API GradientDistortionCorrection& operator= (const GradientDistortionCorrection& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~GradientDistortionCorrection ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit GradientDistortionCorrection (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::GradientDistortionCorrection& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::GradientDistortionCorrection& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::GradientDistortionCorrection& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::GradientDistortionCorrection& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::GradientDistortionCorrection type object
        ///
        /// Returns the DepthSense::GradientDistortionCorrection type object
        ///
        /// \return the DepthSense::GradientDistortionCorrection type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The algorithm to be used
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::GradientDistortionCorrectionAlgorithm algorithm;
        #endif
        /// Gets the value of the GradientDistortionCorrection::algorithm property
        ///
        /// Gets the value of the GradientDistortionCorrection::algorithm property.
        ///
        ///
        /// \return the value of the GradientDistortionCorrection::algorithm property
        ///
        /// \sa setAlgorithm()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::GradientDistortionCorrectionAlgorithm getAlgorithm ();
        /// Sets the value of the GradientDistortionCorrection::algorithm property
        ///
        /// Sets the value of the GradientDistortionCorrection::algorithm property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getAlgorithm(), algorithmIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setAlgorithm (DepthSense::GradientDistortionCorrectionAlgorithm value);
        /// Checks whether property GradientDistortionCorrection::algorithm is read-only
        ///
        /// Checks whether property GradientDistortionCorrection::algorithm is read-only.
        ///
        ///
        /// \return whether property GradientDistortionCorrection::algorithm is read-only
        ///
        /// \sa setAlgorithm()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool algorithmIsReadOnly ();
        /// The coefficient to be used in the gradient distortion correction algorithm
        #ifdef DEPTHSENSE_DOC
        @property std::vector< float > coefficients;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< float > _p_getCoefficients ();
        public:
        /// Gets the value of the GradientDistortionCorrection::coefficients property
        ///
        /// Gets the value of the GradientDistortionCorrection::coefficients property.
        ///
        ///
        /// \return the value of the GradientDistortionCorrection::coefficients property
        ///
        /// \sa setCoefficients()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< float > getCoefficients ()
        {
            std::vector< float > retval = _p_getCoefficients().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setCoefficients (::DSI::Vector< float > value);
        public:
        /// Sets the value of the GradientDistortionCorrection::coefficients property
        ///
        /// Sets the value of the GradientDistortionCorrection::coefficients property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getCoefficients(), coefficientsIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setCoefficients (std::vector< float > value)
        {
            ::DSI::Vector< float > _p_value = DSI::Vector< float >::marshal(value);
            _p_setCoefficients(_p_value);
        }
        /// Checks whether property GradientDistortionCorrection::coefficients is read-only
        ///
        /// Checks whether property GradientDistortionCorrection::coefficients is read-only.
        ///
        ///
        /// \return whether property GradientDistortionCorrection::coefficients is read-only
        ///
        /// \sa setCoefficients()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool coefficientsIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Calibration DepthSense.hxx
    /// The calibration class
    ///
    /// This class holds the calibration for a given configuration
    class Calibration
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Calibration (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Calibration ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Calibration (const Calibration& other);
        DEPTHSENSE_API Calibration& operator= (const Calibration& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Calibration ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Calibration (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Calibration& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Calibration& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Calibration& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Calibration& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Calibration type object
        ///
        /// Returns the DepthSense::Calibration type object
        ///
        /// \return the DepthSense::Calibration type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The phase delay for the first modulation frequency
        #ifdef DEPTHSENSE_DOC
        @property int16_t phaseDelay;
        #endif
        /// Gets the value of the Calibration::phaseDelay property
        ///
        /// Gets the value of the Calibration::phaseDelay property.
        ///
        ///
        /// \return the value of the Calibration::phaseDelay property
        ///
        /// \sa setPhaseDelay()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int16_t getPhaseDelay ();
        /// Sets the value of the Calibration::phaseDelay property
        ///
        /// Sets the value of the Calibration::phaseDelay property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getPhaseDelay(), phaseDelayIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setPhaseDelay (int16_t value);
        /// Checks whether property Calibration::phaseDelay is read-only
        ///
        /// Checks whether property Calibration::phaseDelay is read-only.
        ///
        ///
        /// \return whether property Calibration::phaseDelay is read-only
        ///
        /// \sa setPhaseDelay()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool phaseDelayIsReadOnly ();
        /// Whether the Calibration::phaseDelay was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool phaseDelayLoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::phaseDelayLoadedFromDevice property
        ///
        /// Gets the value of the Calibration::phaseDelayLoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::phaseDelayLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getPhaseDelayLoadedFromDevice ();
        /// The phase delay for the second (dealiasing) modulation frequency
        #ifdef DEPTHSENSE_DOC
        @property int16_t phaseDelay2;
        #endif
        /// Gets the value of the Calibration::phaseDelay2 property
        ///
        /// Gets the value of the Calibration::phaseDelay2 property.
        ///
        ///
        /// \return the value of the Calibration::phaseDelay2 property
        ///
        /// \sa setPhaseDelay2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int16_t getPhaseDelay2 ();
        /// Sets the value of the Calibration::phaseDelay2 property
        ///
        /// Sets the value of the Calibration::phaseDelay2 property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getPhaseDelay2(), phaseDelay2IsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setPhaseDelay2 (int16_t value);
        /// Checks whether property Calibration::phaseDelay2 is read-only
        ///
        /// Checks whether property Calibration::phaseDelay2 is read-only.
        ///
        ///
        /// \return whether property Calibration::phaseDelay2 is read-only
        ///
        /// \sa setPhaseDelay2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool phaseDelay2IsReadOnly ();
        /// Whether the Calibration::phaseDelay2 was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool phaseDelay2LoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::phaseDelay2LoadedFromDevice property
        ///
        /// Gets the value of the Calibration::phaseDelay2LoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::phaseDelay2LoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getPhaseDelay2LoadedFromDevice ();
        /// The temperature correction data
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::TEMPERATURE_CORRECTION_NONE
        /// - 1 for DepthSense::TEMPERATURE_CORRECTION_ONE_FACTOR
        /// - 2 for DepthSense::TEMPERATURE_CORRECTION_TWO_FACTORS
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::TemperatureCorrection temperatureCorrection;
        #endif
        /// Gets the value of the Calibration::temperatureCorrection property
        ///
        /// Gets the value of the Calibration::temperatureCorrection property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::TEMPERATURE_CORRECTION_NONE
        /// - 1 for DepthSense::TEMPERATURE_CORRECTION_ONE_FACTOR
        /// - 2 for DepthSense::TEMPERATURE_CORRECTION_TWO_FACTORS
        ///
        ///
        /// \return the value of the Calibration::temperatureCorrection property
        ///
        /// \sa setTemperatureCorrection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::TemperatureCorrection getTemperatureCorrection ();
        /// Sets the value of the Calibration::temperatureCorrection property
        ///
        /// Sets the value of the Calibration::temperatureCorrection property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::TEMPERATURE_CORRECTION_NONE
        /// - 1 for DepthSense::TEMPERATURE_CORRECTION_ONE_FACTOR
        /// - 2 for DepthSense::TEMPERATURE_CORRECTION_TWO_FACTORS
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getTemperatureCorrection(), temperatureCorrectionIsReadOnly()
        ///
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setTemperatureCorrection (DepthSense::TemperatureCorrection value);
        /// Checks whether property Calibration::temperatureCorrection is read-only
        ///
        /// Checks whether property Calibration::temperatureCorrection is read-only.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::TEMPERATURE_CORRECTION_NONE
        /// - 1 for DepthSense::TEMPERATURE_CORRECTION_ONE_FACTOR
        /// - 2 for DepthSense::TEMPERATURE_CORRECTION_TWO_FACTORS
        ///
        ///
        /// \return whether property Calibration::temperatureCorrection is read-only
        ///
        /// \sa setTemperatureCorrection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool temperatureCorrectionIsReadOnly ();
        /// Whether the Calibration::temperatureCorrection was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool temperatureCorrectionLoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::temperatureCorrectionLoadedFromDevice property
        ///
        /// Gets the value of the Calibration::temperatureCorrectionLoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::temperatureCorrectionLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getTemperatureCorrectionLoadedFromDevice ();
        /// The cyclic error correction data for the first modulation frequency
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::CyclicErrorCorrection cyclicErrorCorrection;
        #endif
        /// Gets the value of the Calibration::cyclicErrorCorrection property
        ///
        /// Gets the value of the Calibration::cyclicErrorCorrection property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        ///
        /// \return the value of the Calibration::cyclicErrorCorrection property
        ///
        /// \sa setCyclicErrorCorrection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::CyclicErrorCorrection getCyclicErrorCorrection ();
        /// Sets the value of the Calibration::cyclicErrorCorrection property
        ///
        /// Sets the value of the Calibration::cyclicErrorCorrection property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getCyclicErrorCorrection(), cyclicErrorCorrectionIsReadOnly()
        ///
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCyclicErrorCorrection (DepthSense::CyclicErrorCorrection value);
        /// Checks whether property Calibration::cyclicErrorCorrection is read-only
        ///
        /// Checks whether property Calibration::cyclicErrorCorrection is read-only.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        ///
        /// \return whether property Calibration::cyclicErrorCorrection is read-only
        ///
        /// \sa setCyclicErrorCorrection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool cyclicErrorCorrectionIsReadOnly ();
        /// Whether the Calibration::cyclicErrorCorrection was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool cyclicErrorCorrectionLoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::cyclicErrorCorrectionLoadedFromDevice property
        ///
        /// Gets the value of the Calibration::cyclicErrorCorrectionLoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::cyclicErrorCorrectionLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getCyclicErrorCorrectionLoadedFromDevice ();
        /// The cyclic error correction data for the second modulation frequency
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::CyclicErrorCorrection cyclicErrorCorrection2;
        #endif
        /// Gets the value of the Calibration::cyclicErrorCorrection2 property
        ///
        /// Gets the value of the Calibration::cyclicErrorCorrection2 property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        ///
        /// \return the value of the Calibration::cyclicErrorCorrection2 property
        ///
        /// \sa setCyclicErrorCorrection2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::CyclicErrorCorrection getCyclicErrorCorrection2 ();
        /// Sets the value of the Calibration::cyclicErrorCorrection2 property
        ///
        /// Sets the value of the Calibration::cyclicErrorCorrection2 property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getCyclicErrorCorrection2(), cyclicErrorCorrection2IsReadOnly()
        ///
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCyclicErrorCorrection2 (DepthSense::CyclicErrorCorrection value);
        /// Checks whether property Calibration::cyclicErrorCorrection2 is read-only
        ///
        /// Checks whether property Calibration::cyclicErrorCorrection2 is read-only.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_NONE
        /// - 4 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_C2S2C4S4
        /// - 16 for DepthSense::CYCLIC_ERROR_CORRECTION_ALGORITHM_INDIRECT_12_HARMONICS_MODEL
        ///
        ///
        /// \return whether property Calibration::cyclicErrorCorrection2 is read-only
        ///
        /// \sa setCyclicErrorCorrection2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool cyclicErrorCorrection2IsReadOnly ();
        /// Whether the Calibration::cyclicErrorCorrection2 was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool cyclicErrorCorrection2LoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::cyclicErrorCorrection2LoadedFromDevice property
        ///
        /// Gets the value of the Calibration::cyclicErrorCorrection2LoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::cyclicErrorCorrection2LoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getCyclicErrorCorrection2LoadedFromDevice ();
        /// The gradient distortion correction data for the first modulation frequency
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::GradientDistortionCorrection gradientDistortionCorrection;
        #endif
        /// Gets the value of the Calibration::gradientDistortionCorrection property
        ///
        /// Gets the value of the Calibration::gradientDistortionCorrection property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        ///
        /// \return the value of the Calibration::gradientDistortionCorrection property
        ///
        /// \sa setGradientDistortionCorrection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::GradientDistortionCorrection getGradientDistortionCorrection ();
        /// Sets the value of the Calibration::gradientDistortionCorrection property
        ///
        /// Sets the value of the Calibration::gradientDistortionCorrection property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getGradientDistortionCorrection(), gradientDistortionCorrectionIsReadOnly()
        ///
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGradientDistortionCorrection (DepthSense::GradientDistortionCorrection value);
        /// Checks whether property Calibration::gradientDistortionCorrection is read-only
        ///
        /// Checks whether property Calibration::gradientDistortionCorrection is read-only.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        ///
        /// \return whether property Calibration::gradientDistortionCorrection is read-only
        ///
        /// \sa setGradientDistortionCorrection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gradientDistortionCorrectionIsReadOnly ();
        /// Whether the Calibration::gradientDistortionCorrection was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool gradientDistortionCorrectionLoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::gradientDistortionCorrectionLoadedFromDevice property
        ///
        /// Gets the value of the Calibration::gradientDistortionCorrectionLoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::gradientDistortionCorrectionLoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getGradientDistortionCorrectionLoadedFromDevice ();
        /// The gradient distortion correction data for the second modulation frequency
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::GradientDistortionCorrection gradientDistortionCorrection2;
        #endif
        /// Gets the value of the Calibration::gradientDistortionCorrection2 property
        ///
        /// Gets the value of the Calibration::gradientDistortionCorrection2 property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        ///
        /// \return the value of the Calibration::gradientDistortionCorrection2 property
        ///
        /// \sa setGradientDistortionCorrection2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::GradientDistortionCorrection getGradientDistortionCorrection2 ();
        /// Sets the value of the Calibration::gradientDistortionCorrection2 property
        ///
        /// Sets the value of the Calibration::gradientDistortionCorrection2 property.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getGradientDistortionCorrection2(), gradientDistortionCorrection2IsReadOnly()
        ///
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGradientDistortionCorrection2 (DepthSense::GradientDistortionCorrection value);
        /// Checks whether property Calibration::gradientDistortionCorrection2 is read-only
        ///
        /// Checks whether property Calibration::gradientDistortionCorrection2 is read-only.
        ///
        /// The expected number of coefficients with respect to the algorithm are:
        /// - 0 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_NONE
        /// - 21 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55
        /// - 42 for DepthSense::GRADIENT_DISTORTION_CORRECTION_ALGORITHM_POLY55_LEFT_RIGHT_COLUMNS
        ///
        ///
        /// \return whether property Calibration::gradientDistortionCorrection2 is read-only
        ///
        /// \sa setGradientDistortionCorrection2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gradientDistortionCorrection2IsReadOnly ();
        /// Whether the Calibration::gradientDistortionCorrection2 was loaded from the device or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool gradientDistortionCorrection2LoadedFromDevice;
        #endif
        /// Gets the value of the Calibration::gradientDistortionCorrection2LoadedFromDevice property
        ///
        /// Gets the value of the Calibration::gradientDistortionCorrection2LoadedFromDevice property.
        ///
        ///
        /// \return the value of the Calibration::gradientDistortionCorrection2LoadedFromDevice property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getGradientDistortionCorrection2LoadedFromDevice ();
        /// The hardware version of the setup used when the configuration was calibrated
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::HardwareVersion hardwareVersion;
        #endif
        /// Gets the value of the Calibration::hardwareVersion property
        ///
        /// Gets the value of the Calibration::hardwareVersion property.
        ///
        ///
        /// \return the value of the Calibration::hardwareVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::HardwareVersion getHardwareVersion ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class HardwareVersion DepthSense.hxx
    /// The hardware version class
    ///
    /// This class holds the version information of all the modules attached to the device
    class HardwareVersion
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API HardwareVersion (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API HardwareVersion ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API HardwareVersion (const HardwareVersion& other);
        DEPTHSENSE_API HardwareVersion& operator= (const HardwareVersion& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~HardwareVersion ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit HardwareVersion (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit HardwareVersion (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::HardwareVersion& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::HardwareVersion& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::HardwareVersion& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::HardwareVersion& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::HardwareVersion type object
        ///
        /// Returns the DepthSense::HardwareVersion type object
        ///
        /// \return the DepthSense::HardwareVersion type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The firmware version of the TOF controller
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t ControllerFirmwareVersion;
        #endif
        /// Gets the value of the HardwareVersion::ControllerFirmwareVersion property
        ///
        /// Gets the value of the HardwareVersion::ControllerFirmwareVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::ControllerFirmwareVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getControllerFirmwareVersion ();
        /// Whether the controller firmware version is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool ControllerFirmwareAvailable;
        #endif
        /// Gets the value of the HardwareVersion::ControllerFirmwareAvailable property
        ///
        /// Gets the value of the HardwareVersion::ControllerFirmwareAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::ControllerFirmwareAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getControllerFirmwareAvailable ();
        /// The firmware version of the USB Backend
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t USBBackendFirmwareVersion;
        #endif
        /// Gets the value of the HardwareVersion::USBBackendFirmwareVersion property
        ///
        /// Gets the value of the HardwareVersion::USBBackendFirmwareVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::USBBackendFirmwareVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getUSBBackendFirmwareVersion ();
        /// Whether the USB backend firmware version is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool USBBackendFirmwareAvailable;
        #endif
        /// Gets the value of the HardwareVersion::USBBackendFirmwareAvailable property
        ///
        /// Gets the value of the HardwareVersion::USBBackendFirmwareAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::USBBackendFirmwareAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getUSBBackendFirmwareAvailable ();
        /// The DepthSense::ModuleId of the Sensor board
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ModuleId SensorBoardVersion;
        #endif
        /// Gets the value of the HardwareVersion::SensorBoardVersion property
        ///
        /// Gets the value of the HardwareVersion::SensorBoardVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::SensorBoardVersion property
        ///
        /// \sa setSensorBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ModuleId getSensorBoardVersion ();
        /// Sets the value of the HardwareVersion::SensorBoardVersion property
        ///
        /// Sets the value of the HardwareVersion::SensorBoardVersion property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getSensorBoardVersion(), SensorBoardVersionIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSensorBoardVersion (DepthSense::ModuleId value);
        /// Checks whether property HardwareVersion::SensorBoardVersion is read-only
        ///
        /// Checks whether property HardwareVersion::SensorBoardVersion is read-only.
        ///
        ///
        /// \return whether property HardwareVersion::SensorBoardVersion is read-only
        ///
        /// \sa setSensorBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool SensorBoardVersionIsReadOnly ();
        /// Whether the sensor board is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool SensorBoardAvailable;
        #endif
        /// Gets the value of the HardwareVersion::SensorBoardAvailable property
        ///
        /// Gets the value of the HardwareVersion::SensorBoardAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::SensorBoardAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getSensorBoardAvailable ();
        /// The DepthSense::ModuleId of the TOF Controller board
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ModuleId ControllerBoardVersion;
        #endif
        /// Gets the value of the HardwareVersion::ControllerBoardVersion property
        ///
        /// Gets the value of the HardwareVersion::ControllerBoardVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::ControllerBoardVersion property
        ///
        /// \sa setControllerBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ModuleId getControllerBoardVersion ();
        /// Sets the value of the HardwareVersion::ControllerBoardVersion property
        ///
        /// Sets the value of the HardwareVersion::ControllerBoardVersion property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getControllerBoardVersion(), ControllerBoardVersionIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setControllerBoardVersion (DepthSense::ModuleId value);
        /// Checks whether property HardwareVersion::ControllerBoardVersion is read-only
        ///
        /// Checks whether property HardwareVersion::ControllerBoardVersion is read-only.
        ///
        ///
        /// \return whether property HardwareVersion::ControllerBoardVersion is read-only
        ///
        /// \sa setControllerBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool ControllerBoardVersionIsReadOnly ();
        /// Whether the controller board is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool ControllerBoardAvailable;
        #endif
        /// Gets the value of the HardwareVersion::ControllerBoardAvailable property
        ///
        /// Gets the value of the HardwareVersion::ControllerBoardAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::ControllerBoardAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getControllerBoardAvailable ();
        /// The DepthSense::ModuleId of the Left Illumination board
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ModuleId LeftIlluminationBoardVersion;
        #endif
        /// Gets the value of the HardwareVersion::LeftIlluminationBoardVersion property
        ///
        /// Gets the value of the HardwareVersion::LeftIlluminationBoardVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::LeftIlluminationBoardVersion property
        ///
        /// \sa setLeftIlluminationBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ModuleId getLeftIlluminationBoardVersion ();
        /// Sets the value of the HardwareVersion::LeftIlluminationBoardVersion property
        ///
        /// Sets the value of the HardwareVersion::LeftIlluminationBoardVersion property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getLeftIlluminationBoardVersion(), LeftIlluminationBoardVersionIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setLeftIlluminationBoardVersion (DepthSense::ModuleId value);
        /// Checks whether property HardwareVersion::LeftIlluminationBoardVersion is read-only
        ///
        /// Checks whether property HardwareVersion::LeftIlluminationBoardVersion is read-only.
        ///
        ///
        /// \return whether property HardwareVersion::LeftIlluminationBoardVersion is read-only
        ///
        /// \sa setLeftIlluminationBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool LeftIlluminationBoardVersionIsReadOnly ();
        /// Whether the sensor board is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool LeftIlluminationBoardAvailable;
        #endif
        /// Gets the value of the HardwareVersion::LeftIlluminationBoardAvailable property
        ///
        /// Gets the value of the HardwareVersion::LeftIlluminationBoardAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::LeftIlluminationBoardAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getLeftIlluminationBoardAvailable ();
        /// The DepthSense::ModuleId of the Right Illumination board
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ModuleId RightIlluminationBoardVersion;
        #endif
        /// Gets the value of the HardwareVersion::RightIlluminationBoardVersion property
        ///
        /// Gets the value of the HardwareVersion::RightIlluminationBoardVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::RightIlluminationBoardVersion property
        ///
        /// \sa setRightIlluminationBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ModuleId getRightIlluminationBoardVersion ();
        /// Sets the value of the HardwareVersion::RightIlluminationBoardVersion property
        ///
        /// Sets the value of the HardwareVersion::RightIlluminationBoardVersion property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getRightIlluminationBoardVersion(), RightIlluminationBoardVersionIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setRightIlluminationBoardVersion (DepthSense::ModuleId value);
        /// Checks whether property HardwareVersion::RightIlluminationBoardVersion is read-only
        ///
        /// Checks whether property HardwareVersion::RightIlluminationBoardVersion is read-only.
        ///
        ///
        /// \return whether property HardwareVersion::RightIlluminationBoardVersion is read-only
        ///
        /// \sa setRightIlluminationBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool RightIlluminationBoardVersionIsReadOnly ();
        /// Whether the sensor board is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool RightIlluminationBoardAvailable;
        #endif
        /// Gets the value of the HardwareVersion::RightIlluminationBoardAvailable property
        ///
        /// Gets the value of the HardwareVersion::RightIlluminationBoardAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::RightIlluminationBoardAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getRightIlluminationBoardAvailable ();
        /// The DepthSense::ModuleId of the Main board
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ModuleId MainBoardVersion;
        #endif
        /// Gets the value of the HardwareVersion::MainBoardVersion property
        ///
        /// Gets the value of the HardwareVersion::MainBoardVersion property.
        ///
        ///
        /// \return the value of the HardwareVersion::MainBoardVersion property
        ///
        /// \sa setMainBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ModuleId getMainBoardVersion ();
        /// Sets the value of the HardwareVersion::MainBoardVersion property
        ///
        /// Sets the value of the HardwareVersion::MainBoardVersion property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getMainBoardVersion(), MainBoardVersionIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setMainBoardVersion (DepthSense::ModuleId value);
        /// Checks whether property HardwareVersion::MainBoardVersion is read-only
        ///
        /// Checks whether property HardwareVersion::MainBoardVersion is read-only.
        ///
        ///
        /// \return whether property HardwareVersion::MainBoardVersion is read-only
        ///
        /// \sa setMainBoardVersion()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool MainBoardVersionIsReadOnly ();
        /// Whether the sensor board is available or not
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool MainBoardAvailable;
        #endif
        /// Gets the value of the HardwareVersion::MainBoardAvailable property
        ///
        /// Gets the value of the HardwareVersion::MainBoardAvailable property.
        ///
        ///
        /// \return the value of the HardwareVersion::MainBoardAvailable property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getMainBoardAvailable ();
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    class SystemStateValue
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::BaseValue
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API SystemStateValue (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API SystemStateValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API SystemStateValue (const SystemStateValue& other);
        DEPTHSENSE_API SystemStateValue& operator= (const SystemStateValue& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~SystemStateValue ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit SystemStateValue (const DepthSense::BaseValue& iface);
        DEPTHSENSE_API explicit SystemStateValue (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::SystemStateValue& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::SystemStateValue& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::SystemStateValue& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::SystemStateValue& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::SystemStateValue type object
        ///
        /// Returns the DepthSense::SystemStateValue type object
        ///
        /// \return the DepthSense::SystemStateValue type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        DEPTHSENSE_API DepthSense::BaseValue getParameter (DepthSense::ParameterType value);
        DEPTHSENSE_API void setParameter (DepthSense::BaseValue value);
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::ParameterType > _p_getParameters ();
        public:
        std::vector< DepthSense::ParameterType > getParameters ()
        {
            std::vector< DepthSense::ParameterType > retval = _p_getParameters().unmarshal();
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        /// The DepthSense::BaseValueType of the object
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::BaseValueType baseValueType;
        #endif
        /// Gets the value of the BaseValue::baseValueType property
        ///
        /// Gets the value of the BaseValue::baseValueType property.
        ///
        ///
        /// \return the value of the BaseValue::baseValueType property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValueType getBaseValueType ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Depth
    {
        /// \class SampleData DepthSense.hxx
        /// A class holding all the sample data
        class SampleData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::BaseValue;
            friend class DepthSense::GPIOValue;
            friend class DepthSense::FloatParameterValue;
            friend class DepthSense::BoolParameterValue;
            friend class DepthSense::IntParameterValue;
            friend class DepthSense::RegionOfInterestValue;
            friend class DepthSense::I2CArrayValue;
            friend class DepthSense::RegisterValue;
            friend class DepthSense::SystemInfoValue;
            friend class DepthSense::SystemCalibrationValue;
            friend class DepthSense::TemperatureCorrection;
            friend class DepthSense::CyclicErrorCorrection;
            friend class DepthSense::GradientDistortionCorrection;
            friend class DepthSense::Calibration;
            friend class DepthSense::HardwareVersion;
            friend class DepthSense::SystemStateValue;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::Depth::SampleDataEx;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleData (const SampleData& other);
            DEPTHSENSE_API SampleData& operator= (const SampleData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::SampleData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::SampleData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::SampleData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::SampleData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::SampleData type object
            ///
            /// Returns the DepthSense::Depth::SampleData type object
            ///
            /// \return the DepthSense::Depth::SampleData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The confidence map
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > confidenceMap;
            #endif
            /// Gets the value of the SampleData::confidenceMap property
            ///
            /// Gets the value of the SampleData::confidenceMap property.
            ///
            ///
            /// \return the value of the SampleData::confidenceMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getConfidenceMap ();
            /// The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > phaseMap;
            #endif
            /// Gets the value of the SampleData::phaseMap property
            ///
            /// Gets the value of the SampleData::phaseMap property.
            ///
            ///
            /// \return the value of the SampleData::phaseMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getPhaseMap ();
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > depthMap;
            #endif
            /// Gets the value of the SampleData::depthMap property
            ///
            /// Gets the value of the SampleData::depthMap property.
            ///
            ///
            /// \return the value of the SampleData::depthMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getDepthMap ();
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< float > depthMapFloatingPoint;
            #endif
            /// Gets the value of the SampleData::depthMapFloatingPoint property
            ///
            /// Gets the value of the SampleData::depthMapFloatingPoint property.
            ///
            ///
            /// \return the value of the SampleData::depthMapFloatingPoint property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< float > getDepthMapFloatingPoint ();
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            #endif
            /// Gets the value of the SampleData::vertices property
            ///
            /// Gets the value of the SampleData::vertices property.
            ///
            ///
            /// \return the value of the SampleData::vertices property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::Vertex > getVertices ();
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            #endif
            /// Gets the value of the SampleData::verticesFloatingPoint property
            ///
            /// Gets the value of the SampleData::verticesFloatingPoint property.
            ///
            ///
            /// \return the value of the SampleData::verticesFloatingPoint property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::FPVertex > getVerticesFloatingPoint ();
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::UV > uvMap;
            #endif
            /// Gets the value of the SampleData::uvMap property
            ///
            /// Gets the value of the SampleData::uvMap property.
            ///
            ///
            /// \return the value of the SampleData::uvMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::UV > getUvMap ();
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::Acceleration acceleration;
            #endif
            /// Gets the value of the SampleData::acceleration property
            ///
            /// Gets the value of the SampleData::acceleration property.
            ///
            ///
            /// \return the value of the SampleData::acceleration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::Acceleration getAcceleration ();
            /// The system model parameters that were in effect at the time of capture. The coordinate system used 
            /// for the extrinsics is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::StereoCameraParameters stereoCameraParameters;
            #endif
            /// Gets the value of the SampleData::stereoCameraParameters property
            ///
            /// Gets the value of the SampleData::stereoCameraParameters property.
            ///
            ///
            /// \return the value of the SampleData::stereoCameraParameters property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::StereoCameraParameters getStereoCameraParameters ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleData::captureConfiguration property
            ///
            /// Gets the value of the SampleData::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleData::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::Configuration getCaptureConfiguration ();
            /// The name of the configuration used to capture the configuration.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::string captureConfigurationName;
            #endif
            private:
            DEPTHSENSE_API ::DSI::String _p_getCaptureConfigurationName ();
            public:
            /// Gets the value of the SampleData::captureConfigurationName property
            ///
            /// Gets the value of the SampleData::captureConfigurationName property.
            ///
            ///
            /// \return the value of the SampleData::captureConfigurationName property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::string getCaptureConfigurationName ()
            {
                std::string retval = _p_getCaptureConfigurationName().unmarshal();
                return retval;
            }
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleData::timeOfCapture property
            ///
            /// Gets the value of the SampleData::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleData::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// the time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleData::timeOfArrival property
            ///
            /// Gets the value of the SampleData::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleData::droppedSampleCount property
            ///
            /// Gets the value of the SampleData::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            /// The IMU state when the frame was captured.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::IMUData imuData;
            #endif
            /// Gets the value of the SampleData::imuData property
            ///
            /// Gets the value of the SampleData::imuData property.
            ///
            ///
            /// \return the value of the SampleData::imuData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::IMUData getImuData ();
            /// The exposure histogram
            ///
            /// The exposure histogram contains the absolute exposure statistics
            /// within the frame. Exposure values are proportional to the amount
            /// of the total detected photons (from modulated and ambient light
            /// combined). Each bin contains half of the number of pixels of which
            /// exposure falls within the interval specified by the respective bin
            /// edge values
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::vector< uint32_t > exposureHistogram;
            #endif
            private:
            DEPTHSENSE_API ::DSI::Vector< uint32_t > _p_getExposureHistogram ();
            public:
            /// Gets the value of the SampleData::exposureHistogram property
            ///
            /// Gets the value of the SampleData::exposureHistogram property.
            ///
            /// The exposure histogram contains the absolute exposure statistics
            /// within the frame. Exposure values are proportional to the amount
            /// of the total detected photons (from modulated and ambient light
            /// combined). Each bin contains half of the number of pixels of which
            /// exposure falls within the interval specified by the respective bin
            /// edge values
            ///
            /// \return the value of the SampleData::exposureHistogram property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::vector< uint32_t > getExposureHistogram ()
            {
                std::vector< uint32_t > retval = _p_getExposureHistogram().unmarshal();
                return retval;
            }
            /// The \c CoordinateSystemType used
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::CoordinateSystemType coordinateSystemType;
            #endif
            /// Gets the value of the SampleData::coordinateSystemType property
            ///
            /// Gets the value of the SampleData::coordinateSystemType property.
            ///
            ///
            /// \return the value of the SampleData::coordinateSystemType property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::CoordinateSystemType getCoordinateSystemType ();
            /// A mask of the active lasers when the frame was captured
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint32_t activeLasers;
            #endif
            /// Gets the value of the SampleData::activeLasers property
            ///
            /// Gets the value of the SampleData::activeLasers property.
            ///
            ///
            /// \return the value of the SampleData::activeLasers property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint32_t getActiveLasers ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    namespace Depth
    {
        /// \class SampleDataEx DepthSense.hxx
        /// A class holding all the sample data
        class SampleDataEx
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleDataEx (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::BaseValue;
            friend class DepthSense::GPIOValue;
            friend class DepthSense::FloatParameterValue;
            friend class DepthSense::BoolParameterValue;
            friend class DepthSense::IntParameterValue;
            friend class DepthSense::RegionOfInterestValue;
            friend class DepthSense::I2CArrayValue;
            friend class DepthSense::RegisterValue;
            friend class DepthSense::SystemInfoValue;
            friend class DepthSense::SystemCalibrationValue;
            friend class DepthSense::TemperatureCorrection;
            friend class DepthSense::CyclicErrorCorrection;
            friend class DepthSense::GradientDistortionCorrection;
            friend class DepthSense::Calibration;
            friend class DepthSense::HardwareVersion;
            friend class DepthSense::SystemStateValue;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleDataEx ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleDataEx (const SampleDataEx& other);
            DEPTHSENSE_API SampleDataEx& operator= (const SampleDataEx& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleDataEx ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleDataEx (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::SampleDataEx& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::SampleDataEx& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::SampleDataEx& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::SampleDataEx& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::SampleDataEx type object
            ///
            /// Returns the DepthSense::Depth::SampleDataEx type object
            ///
            /// \return the DepthSense::Depth::SampleDataEx type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The confidence map
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > confidenceMap;
            #endif
            /// Gets the value of the SampleDataEx::confidenceMap property
            ///
            /// Gets the value of the SampleDataEx::confidenceMap property.
            ///
            ///
            /// \return the value of the SampleDataEx::confidenceMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getConfidenceMap ();
            /// The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > phaseMap;
            #endif
            /// Gets the value of the SampleDataEx::phaseMap property
            ///
            /// Gets the value of the SampleDataEx::phaseMap property.
            ///
            ///
            /// \return the value of the SampleDataEx::phaseMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getPhaseMap ();
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > depthMap;
            #endif
            /// Gets the value of the SampleDataEx::depthMap property
            ///
            /// Gets the value of the SampleDataEx::depthMap property.
            ///
            ///
            /// \return the value of the SampleDataEx::depthMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getDepthMap ();
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< float > depthMapFloatingPoint;
            #endif
            /// Gets the value of the SampleDataEx::depthMapFloatingPoint property
            ///
            /// Gets the value of the SampleDataEx::depthMapFloatingPoint property.
            ///
            ///
            /// \return the value of the SampleDataEx::depthMapFloatingPoint property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< float > getDepthMapFloatingPoint ();
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            #endif
            /// Gets the value of the SampleDataEx::vertices property
            ///
            /// Gets the value of the SampleDataEx::vertices property.
            ///
            ///
            /// \return the value of the SampleDataEx::vertices property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::Vertex > getVertices ();
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            #endif
            /// Gets the value of the SampleDataEx::verticesFloatingPoint property
            ///
            /// Gets the value of the SampleDataEx::verticesFloatingPoint property.
            ///
            ///
            /// \return the value of the SampleDataEx::verticesFloatingPoint property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::FPVertex > getVerticesFloatingPoint ();
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::UV > uvMap;
            #endif
            /// Gets the value of the SampleDataEx::uvMap property
            ///
            /// Gets the value of the SampleDataEx::uvMap property.
            ///
            ///
            /// \return the value of the SampleDataEx::uvMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::UV > getUvMap ();
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::Acceleration acceleration;
            #endif
            /// Gets the value of the SampleDataEx::acceleration property
            ///
            /// Gets the value of the SampleDataEx::acceleration property.
            ///
            ///
            /// \return the value of the SampleDataEx::acceleration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::Acceleration getAcceleration ();
            /// The system model parameters that were in effect at the time of capture. The coordinate system used 
            /// for the extrinsics is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::StereoCameraParameters stereoCameraParameters;
            #endif
            /// Gets the value of the SampleDataEx::stereoCameraParameters property
            ///
            /// Gets the value of the SampleDataEx::stereoCameraParameters property.
            ///
            ///
            /// \return the value of the SampleDataEx::stereoCameraParameters property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::StereoCameraParameters getStereoCameraParameters ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleDataEx::captureConfiguration property
            ///
            /// Gets the value of the SampleDataEx::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleDataEx::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::Configuration getCaptureConfiguration ();
            /// The name of the configuration used to capture the configuration.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::string captureConfigurationName;
            #endif
            private:
            DEPTHSENSE_API ::DSI::String _p_getCaptureConfigurationName ();
            public:
            /// Gets the value of the SampleDataEx::captureConfigurationName property
            ///
            /// Gets the value of the SampleDataEx::captureConfigurationName property.
            ///
            ///
            /// \return the value of the SampleDataEx::captureConfigurationName property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::string getCaptureConfigurationName ()
            {
                std::string retval = _p_getCaptureConfigurationName().unmarshal();
                return retval;
            }
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleDataEx::timeOfCapture property
            ///
            /// Gets the value of the SampleDataEx::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleDataEx::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// the time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleDataEx::timeOfArrival property
            ///
            /// Gets the value of the SampleDataEx::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleDataEx::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleDataEx::droppedSampleCount property
            ///
            /// Gets the value of the SampleDataEx::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleDataEx::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleDataEx::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleDataEx::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleDataEx::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            /// The raw data as received from the device.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > rawData;
            #endif
            /// Gets the value of the SampleDataEx::rawData property
            ///
            /// Gets the value of the SampleDataEx::rawData property.
            ///
            ///
            /// \return the value of the SampleDataEx::rawData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getRawData ();
            /// The ambient map.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint16_t > ambientMap;
            #endif
            /// Gets the value of the SampleDataEx::ambientMap property
            ///
            /// Gets the value of the SampleDataEx::ambientMap property.
            ///
            ///
            /// \return the value of the SampleDataEx::ambientMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint16_t > getAmbientMap ();
            /// The temperature reported by the sensors when the frame was captured.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::vector< DepthSense::SensorValue > sensorValues;
            #endif
            private:
            DEPTHSENSE_API ::DSI::Vector< DepthSense::SensorValue > _p_getSensorValues ();
            public:
            /// Gets the value of the SampleDataEx::sensorValues property
            ///
            /// Gets the value of the SampleDataEx::sensorValues property.
            ///
            ///
            /// \return the value of the SampleDataEx::sensorValues property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::vector< DepthSense::SensorValue > getSensorValues ()
            {
                std::vector< DepthSense::SensorValue > retval = _p_getSensorValues().unmarshal();
                return retval;
            }
            /// The IMU state when the frame was captured.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::IMUData imuData;
            #endif
            /// Gets the value of the SampleDataEx::imuData property
            ///
            /// Gets the value of the SampleDataEx::imuData property.
            ///
            ///
            /// \return the value of the SampleDataEx::imuData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::IMUData getImuData ();
            /// The exposure histogram
            ///
            /// The exposure histogram contains the absolute exposure statistics
            /// within the frame. Exposure values are proportional to the amount
            /// of the total detected photons (from modulated and ambient light
            /// combined).
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::vector< uint32_t > exposureHistogram;
            #endif
            private:
            DEPTHSENSE_API ::DSI::Vector< uint32_t > _p_getExposureHistogram ();
            public:
            /// Gets the value of the SampleDataEx::exposureHistogram property
            ///
            /// Gets the value of the SampleDataEx::exposureHistogram property.
            ///
            /// The exposure histogram contains the absolute exposure statistics
            /// within the frame. Exposure values are proportional to the amount
            /// of the total detected photons (from modulated and ambient light
            /// combined).
            ///
            /// \return the value of the SampleDataEx::exposureHistogram property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::vector< uint32_t > getExposureHistogram ()
            {
                std::vector< uint32_t > retval = _p_getExposureHistogram().unmarshal();
                return retval;
            }
            /// The \c CoordinateSystemType used
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::CoordinateSystemType coordinateSystemType;
            #endif
            /// Gets the value of the SampleDataEx::coordinateSystemType property
            ///
            /// Gets the value of the SampleDataEx::coordinateSystemType property.
            ///
            ///
            /// \return the value of the SampleDataEx::coordinateSystemType property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::CoordinateSystemType getCoordinateSystemType ();
            /// A mask of the active lasers .
            /// 
            /// A mask of the active lasers when the frame was captured.
            ///
            /// \sa DepthSense::isLaserActive
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint32_t activeLasers;
            #endif
            /// Gets the value of the SampleDataEx::activeLasers property
            ///
            /// Gets the value of the SampleDataEx::activeLasers property.
            ///
            /// \sa DepthSense::isLaserActive
            ///
            /// \return the value of the SampleDataEx::activeLasers property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint32_t getActiveLasers ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    namespace Depth
    {
        /// \class ButtonEventData DepthSense.hxx
        /// The hardware button corresponding data
        class ButtonEventData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API ButtonEventData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::BaseValue;
            friend class DepthSense::GPIOValue;
            friend class DepthSense::FloatParameterValue;
            friend class DepthSense::BoolParameterValue;
            friend class DepthSense::IntParameterValue;
            friend class DepthSense::RegionOfInterestValue;
            friend class DepthSense::I2CArrayValue;
            friend class DepthSense::RegisterValue;
            friend class DepthSense::SystemInfoValue;
            friend class DepthSense::SystemCalibrationValue;
            friend class DepthSense::TemperatureCorrection;
            friend class DepthSense::CyclicErrorCorrection;
            friend class DepthSense::GradientDistortionCorrection;
            friend class DepthSense::Calibration;
            friend class DepthSense::HardwareVersion;
            friend class DepthSense::SystemStateValue;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::SampleDataEx;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API ButtonEventData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API ButtonEventData (const ButtonEventData& other);
            DEPTHSENSE_API ButtonEventData& operator= (const ButtonEventData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~ButtonEventData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit ButtonEventData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::ButtonEventData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::ButtonEventData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::ButtonEventData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::ButtonEventData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::ButtonEventData type object
            ///
            /// Returns the DepthSense::Depth::ButtonEventData type object
            ///
            /// \return the DepthSense::Depth::ButtonEventData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// get the ID of the button for which we triggered the event
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::ButtonID buttonID;
            #endif
            /// Gets the value of the ButtonEventData::buttonID property
            ///
            /// Gets the value of the ButtonEventData::buttonID property.
            ///
            ///
            /// \return the value of the ButtonEventData::buttonID property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::ButtonID getButtonID ();
            /// the time of arrival of the button event in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the ButtonEventData::timeOfArrival property
            ///
            /// Gets the value of the ButtonEventData::timeOfArrival property.
            ///
            ///
            /// \return the value of the ButtonEventData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    namespace Depth
    {
    };
    /// \class DepthNode DepthSense.hxx
    /// Represents a depth stream data source
    ///
    /// The DepthNode class allows to capture depth data with the depth sensor
    /// of a given camera device.
    class DepthNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API DepthNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API DepthNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DepthNode (const DepthNode& other);
        DEPTHSENSE_API DepthNode& operator= (const DepthNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~DepthNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit DepthNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit DepthNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::DepthNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::DepthNode type object
        ///
        /// Returns the DepthSense::DepthNode type object
        ///
        /// \return the DepthSense::DepthNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The mode of the camera
        ///
        /// A type enumerating the various operating modes supported
        /// by depth sensors.
        enum CameraMode
        {
            CAMERA_MODE_UNKNOWN = -1,
            CAMERA_MODE_CLOSE_MODE = 0,
            CAMERA_MODE_LONG_RANGE = 1,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String CameraMode_toString_p (CameraMode value);
        #endif
        /// Converts a DepthSense::DepthNode::CameraMode value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::CameraMode, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string CameraMode_toString (CameraMode value)
        {
            return CameraMode_toString_p(value).unmarshal();
        }
        enum OverheatingStatus
        {
            OVERHEATING_STATUS_TEMPERATURE_NORMAL = 0,
            OVERHEATING_STATUS_SOFT_OVERHEATING = 1,
            OVERHEATING_STATUS_HARD_OVERHEATING = 2,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String OverheatingStatus_toString_p (OverheatingStatus value);
        #endif
        /// Converts a DepthSense::DepthNode::OverheatingStatus value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::OverheatingStatus, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string OverheatingStatus_toString (OverheatingStatus value)
        {
            return OverheatingStatus_toString_p(value).unmarshal();
        }
        enum OV0570FPGAOperation
        {
            OV0570FPGAOPERATION_WRITE = 0,
            OV0570FPGAOPERATION_SKIP = 1,
            OV0570FPGAOPERATION_SKIP_AND_STOP = 2,
            OV0570FPGAOPERATION_START = 3,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String OV0570FPGAOperation_toString_p (OV0570FPGAOperation value);
        #endif
        /// Converts a DepthSense::DepthNode::OV0570FPGAOperation value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::OV0570FPGAOperation, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string OV0570FPGAOperation_toString (OV0570FPGAOperation value)
        {
            return OV0570FPGAOperation_toString_p(value).unmarshal();
        }
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a depth node
        ///   
        /// The Configuration struct holds the configuration of a depth node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param mode the value of the Configuration::mode field
            /// \param saturation the value of the Configuration::saturation field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::DepthNode::CameraMode mode, bool saturation);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the mode
            DepthSense::DepthNode::CameraMode mode;
            /// whether the saturation is enabled or not
            bool saturation;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// \struct Acceleration DepthSense.hxx
        /// The acceleration returned by the camera
        ///
        /// The Acceleration struct holds the 3 axis acceleration
        /// expressed in g (9.81 m/s) units. Coordinates are
        /// expressed in the same coordinates as the vertices.
        struct DEPTHSENSE_API Acceleration
        {
            Acceleration ();
            /// Constructs a Acceleration instance
            ///
            /// Constructs a Acceleration instance, initializing the instance fields with the provided values.
            ///
            /// \param x the value of the Acceleration::x field
            /// \param y the value of the Acceleration::y field
            /// \param z the value of the Acceleration::z field
            Acceleration (float x, float y, float z);
            /// the x acceleration
            float x;
            /// the y acceleration
            float y;
            /// the z acceleration
            float z;
            /// Compares two Acceleration instances for equality
            ///
            /// Checks whether the current Acceleration instance is equal to the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Acceleration& other) const;
            /// Compares two Acceleration instances for inequality
            ///
            /// Checks whether the current Acceleration instance is different from the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Acceleration& other) const;
        };
        /// Set the active configuration by name
        ///
        /// When setting a new active configuration, the active calibration will be reset to 0 and the
        /// active configuration will be flushed and replaced with the provided one. The newly active 
        /// configuration will be written immediately on the device.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::ArgumentException the name doesn't match any known configuration
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        ///
        /// \param name the name of the configuration to be used
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfigurationByName (const char* name);
        /// Start the burnin of the node
        ///   
        /// Start the burnin of the node. The DepthSense::DepthNode::disableAutoConfiguration
        /// property has no effect.
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void startBurnIn ();
        /// Stop the burnin of the node
        ///   
        /// Stop the burnin of the node.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void stopBurnIn ();
        /// Reload calibration data from the device
        ///
        /// Reload calibration data from the device. The maintenance
        /// password should be set prior to call this method.
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void reloadCalibration ();
        /// Set a register of the USB backend
        ///   
        /// Set a register of the USB backend
        ///
        /// \param address the address of the register to be written to
        /// \param value the value to be written
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setUSBBackendRegister (uint32_t address, uint32_t value);
        /// Get data from the USB Backend
        ///   
        /// Get data from the USB Backend
        ///
        /// \param address the address of the register to read from
        /// \return the value of the register
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getUSBBackendRegister (uint32_t address);
        /// Set a register of the TOF controller
        ///   
        /// Set a register of the TOF controller
        ///
        /// \param address the address of the register to be written to
        /// \param value the value to be written
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setTOFControllerRegister (uint32_t address, uint32_t value);
        /// Get data from the TOF Controller
        ///   
        /// Get data from the TOF Controller
        ///
        /// \param address the address of the register to read from
        /// \return the value of the register
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getTOFControllerRegister (uint32_t address);
        /// Set a register of an i2c device
        ///   
        /// Set a register of an i2c device using one byte for address 
        /// and one byte for data
        ///
        /// \param i2cAddress the 7 bits i2c address of the device
        /// \param address the address of the register to be written to
        /// \param value the value to be written
        /// \param addressBytes the number of bytes for the address of the register
        /// \param dataBytes the number of bytes for the data
        /// \param byteOrder the order in which the data bytes should be read
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setI2c (uint8_t i2cAddress, uint32_t address, uint32_t value, uint8_t addressBytes, uint8_t dataBytes, bool byteOrder);
        /// Get a register of an i2c device
        ///   
        /// Get a register of an i2c device using one byte for address 
        /// and one byte for data
        ///
        /// \param i2cAddress the 7 bits i2c address of the device
        /// \param address the address of the register to read from
        /// \param addressBytes the number of bytes for the address of the register
        /// \param dataBytes the number of bytes for the data
        /// \param byteOrder the order in which the data bytes should be sent
        /// \return the value of the register
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getI2c (uint8_t i2cAddress, uint32_t address, uint8_t addressBytes, uint8_t dataBytes, bool byteOrder);
        /// Set the USB backend status
        ///   
        /// Set the USB backend status
        ///
        /// \param data the value to set the serial flash status to
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setUSBBackendStatus (uint32_t data);
        /// Get the USB backend status
        ///   
        /// Get the USB backend status
        ///
        /// \return the status of the serial flash
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getUSBBackendStatus ();
        private:
        DEPTHSENSE_API void _p_setUSBBackendFirmware (uint32_t address, ::DSI::Vector< uint8_t > data);
        public:
        /// Write an array of bytes in USB Backend Firmware memory
        ///   
        /// Write an array of bytes in USB Backend Firmware memory
        ///
        /// \param address the start address to be written to
        /// \param data the array of data to write to the USB Backend Firmware memory
        ///
        /// \exception DepthSense::ArgumentException one of the argument is wrong
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setUSBBackendFirmware (uint32_t address, std::vector< uint8_t > data)
        {
            ::DSI::Vector< uint8_t > _p_data = DSI::Vector< uint8_t >::marshal(data);
            _p_setUSBBackendFirmware(address, _p_data);
        }
        private:
        DEPTHSENSE_API ::DSI::Vector< uint8_t > _p_getUSBBackendFirmware (uint32_t address, uint32_t length);
        public:
        /// Read an array of bytes from USB Backend Firmware memory
        ///   
        /// Read an array of bytes from USB Backend Firmware memory
        ///
        /// \param address the start address to read from
        /// \param length the length of the data to be read
        /// \return the array of data read from the USB Backend Firmware memory
        ///
        /// \exception DepthSense::ArgumentException one of the argument is wrong
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< uint8_t > getUSBBackendFirmware (uint32_t address, uint32_t length)
        {
            std::vector< uint8_t > retval = _p_getUSBBackendFirmware(address, length).unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setUSBBackendConfiguration (uint32_t address, ::DSI::Vector< uint8_t > data);
        public:
        /// Write an array of bytes in USB Backend Configuration memory
        ///   
        /// Write an array of bytes in USB Backend Configuration memory
        ///
        /// \param address the start address to be written to
        /// \param data the array of data to write to the USB Backend Configuration memory
        ///
        /// \exception DepthSense::ArgumentException one of the argument is wrong
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setUSBBackendConfiguration (uint32_t address, std::vector< uint8_t > data)
        {
            ::DSI::Vector< uint8_t > _p_data = DSI::Vector< uint8_t >::marshal(data);
            _p_setUSBBackendConfiguration(address, _p_data);
        }
        private:
        DEPTHSENSE_API void _p_setTOFControllerFirmware (uint32_t address, ::DSI::Vector< uint8_t > data);
        public:
        /// Write an array of bytes in TOF Controller Firmware memory
        ///   
        /// Write an array of bytes in TOF Controller Firmware memory
        ///
        /// \param address the start address to be written to
        /// \param data the array of data to write to the FPGA Firmware memory
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setTOFControllerFirmware (uint32_t address, std::vector< uint8_t > data)
        {
            ::DSI::Vector< uint8_t > _p_data = DSI::Vector< uint8_t >::marshal(data);
            _p_setTOFControllerFirmware(address, _p_data);
        }
        private:
        DEPTHSENSE_API ::DSI::Vector< uint8_t > _p_getUSBBackendConfiguration (uint32_t address, uint32_t length);
        public:
        /// Read an array of bytes from USB Backend Configuration memory
        ///   
        /// Read an array of bytes from USB Backend Configuration memory
        ///
        /// \param address the start address to read from
        /// \param length the length of the data to be read
        /// \return the array of data read from the USB Backend Configuration memory
        ///
        /// \exception DepthSense::ArgumentException one of the argument is wrong
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< uint8_t > getUSBBackendConfiguration (uint32_t address, uint32_t length)
        {
            std::vector< uint8_t > retval = _p_getUSBBackendConfiguration(address, length).unmarshal();
            return retval;
        }
        /// Erase the USB backend memory
        ///   
        /// Erase the USB backend memory
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void chipEraseUSBBackend ();
        /// Erase a sector of the USB backend configuration memory
        ///   
        /// Erase a sector of the USB backend configuration memory
        ///
        /// \param address one address belonging to the sector to be erased
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void sectorEraseUSBBackendConfiguration (uint32_t address);
        /// Erase a sector of the USB backend firmware memory
        ///   
        /// Erase a sector of the USB backend firmware memory
        ///
        /// \param address one address belonging to the sector to be erased
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void sectorEraseUSBBackendFirmware (uint32_t address);
        /// Write enable the USB backend memory
        ///   
        /// Write enable the USB backend memory
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void writeEnableUSBBackend (bool enable);
        /// Open the device
        ///
        /// Open the device. The DepthNode::maintenancePassword should be set
        /// and the context must have the control over the node.
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void open ();
        /// Close the device
        ///
        /// Close the device. The DepthNode::maintenancePassword should be set
        /// and the context must have the control over the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void close ();
        private:
        DEPTHSENSE_API ::DSI::String _p_getProductionID ();
        public:
        /// Get the production ID
        ///
        /// Get the production ID
        ///
        /// \return the production ID
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getProductionID ()
        {
            std::string retval = _p_getProductionID().unmarshal();
            return retval;
        }
        /// Set the production ID
        ///
        /// Set the production ID of the current camera. Production ID will be written to ROM
        ///
        /// \param value the production id to write in ROM
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the string to write is too long
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setProductionID (const char* value);
        private:
        DEPTHSENSE_API void _p_setPhaseDelays (::DSI::Vector< int16_t > values);
        public:
        /// Set the phase delays
        ///
        /// Set the phase delays of the current camera. Phase delays will be written to ROM.
        ///
        /// \param value the phase delays to write in ROM. This array shoud be of size 1 for DS311, 8 for DS325 v1 and 4 for DS325 v2 where the calibration values are sorted as: [CLOSE_MODE,25],[CLOSE_MODE,30],[CLOSE_MODE,50],[CLOSE_MODE,60],[LONG_MODE,25],[LONG_MODE,30],[LONG_MODE,50],[LONG_MODE,60]
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the array is not of the expected size
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setPhaseDelays (std::vector< int16_t > values)
        {
            ::DSI::Vector< int16_t > _p_values = DSI::Vector< int16_t >::marshal(values);
            _p_setPhaseDelays(_p_values);
        }
        /// Set the serial number
        ///
        /// Set the serial number of the current camera. Serial number will be written to ROM.
        ///
        /// \param value the string to be written to ROM
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the string is too long or empty
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSerialNumber (const char* value);
        /// Set the accelerometer calibration
        ///
        /// Write the accelerometer calibration of the current camera. Accelerometer calibration will be written to ROM. The coordinate system used 
        /// should be the one specified through \c coordinateSystemType property.
        ///
        /// \param value the accelerometer offset to be stored in ROM
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the string is too long or empty
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setAccelerometerCalibration (DepthSense::DepthNode::Acceleration value);
        /// Get the accelerometer calibration
        ///
        /// Get the accelerometer calibration of the current camera. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        ///
        /// \return the accelerometer calibration
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has  not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the string is too long or empty
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::Acceleration getAccelerometerCalibration ();
        private:
        DEPTHSENSE_API void _p_setTemperatureCalibration (DepthSense::DepthNode::CameraMode mode, ::DSI::Vector< DepthSense::SensorValue > value);
        public:
        /// Set the temperature calibration
        ///
        /// Write the temperature calibration of the current camera for the specified camera mode. Temperature calibration will be written to ROM.
        ///
        /// \param mode the camera mode
        /// \param value the temperature calibration
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has  not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the string is too long or empty
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setTemperatureCalibration (DepthSense::DepthNode::CameraMode mode, std::vector< DepthSense::SensorValue > value)
        {
            ::DSI::Vector< DepthSense::SensorValue > _p_value = DSI::Vector< DepthSense::SensorValue >::marshal(value);
            _p_setTemperatureCalibration(mode, _p_value);
        }
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::SensorValue > _p_getTemperatureCalibration (DepthSense::DepthNode::CameraMode mode);
        public:
        /// Get the temperature calibration for the specified camera mode
        ///
        /// Get the temperature calibration of the current camera for the specified camera mode.
        ///
        /// \param mode the camera mode
        /// \return the temperature calibration
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has  not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the string is too long or empty
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::SensorValue > getTemperatureCalibration (DepthSense::DepthNode::CameraMode mode)
        {
            std::vector< DepthSense::SensorValue > retval = _p_getTemperatureCalibration(mode).unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::SensorValue > _p_readTemperatures ();
        public:
        /// Read the temperature sensors
        ///
        /// Read the temperature sensors
        ///
        /// \return the temperature sensor values
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, the stream is already enabled or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::SensorValue > readTemperatures ()
        {
            std::vector< DepthSense::SensorValue > retval = _p_readTemperatures().unmarshal();
            return retval;
        }
        /// Check the temperature sensor values against the thresholds
        ///
        /// Check the temperature sensor values against the thresholds and take action accordingly
        ///
        /// \return TEMPERATURE_NORMAL if no threshold is reached, SOFT_OVERHEATING if any soft threshold has been reached or HARD_OVERHEATING if any hard threshold has been reached
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, the stream is already enabled or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::OverheatingStatus checkTemperatures ();
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::SensorValue > _p_getSoftTemperatureThresholds ();
        public:
        /// Read the soft temperature thresholds
        ///
        /// Read the soft temperature thresholds
        ///
        /// \return the soft temperature threshold values
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, the stream is already enabled or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::SensorValue > getSoftTemperatureThresholds ()
        {
            std::vector< DepthSense::SensorValue > retval = _p_getSoftTemperatureThresholds().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::SensorValue > _p_getHardTemperatureThresholds ();
        public:
        /// Read the hard temperature thresholds
        ///
        /// Read the hard temperature thresholds
        ///
        /// \return the hard temperature threshold values
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, the stream is already enabled or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::SensorValue > getHardTemperatureThresholds ()
        {
            std::vector< DepthSense::SensorValue > retval = _p_getHardTemperatureThresholds().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setFPGAControl (DepthSense::DepthNode::OV0570FPGAOperation operation, uint32_t startAddress, ::DSI::Vector< uint8_t > data);
        public:
        /// Send data to FPGA
        ///   
        /// Send data to FPGA
        ///
        /// \param data a vector containing the data to be written to EEPROM
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setFPGAControl (DepthSense::DepthNode::OV0570FPGAOperation operation, uint32_t startAddress, std::vector< uint8_t > data)
        {
            ::DSI::Vector< uint8_t > _p_data = DSI::Vector< uint8_t >::marshal(data);
            _p_setFPGAControl(operation, startAddress, _p_data);
        }
        /// initialize UVC Backend for firmware flash
        ///   
        /// initialize UVC Backend for firmware flash
        ///
        /// \param startAddress the start address
        /// \param length the length of the data to be written
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void startUSBBackendFirmwareFlash (uint32_t startAddress, uint32_t length);
        private:
        DEPTHSENSE_API void _p_writeUSBBackendFirmwareFlash (::DSI::Vector< uint8_t > data);
        public:
        /// write data to the UVC Backend ROM
        ///   
        /// write data to the UVC Backend ROM. DepthNode::startUSBBackendFirmwareFlash should be called prior to 
        /// write data to the UVC Backend ROM. Once the data has been written DepthNode::stopUSBBackendFirmwareFlash
        /// should be called.
        ///
        /// \param data the data to be written
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void writeUSBBackendFirmwareFlash (std::vector< uint8_t > data)
        {
            ::DSI::Vector< uint8_t > _p_data = DSI::Vector< uint8_t >::marshal(data);
            _p_writeUSBBackendFirmwareFlash(_p_data);
        }
        /// stop UVC Backend firmware flash
        ///   
        /// stop UVC Backend firmware flash
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void stopUSBBackendFirmwareFlash ();
        /// initialize UVC Backend for firmware dump
        ///   
        /// initialize UVC Backend for firmware dump
        ///
        /// \param startAddress the start address
        /// \param length the length of the data to be read
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void startUSBBackendFirmwareDump (uint32_t startAddress, uint32_t length);
        private:
        DEPTHSENSE_API ::DSI::Vector< uint8_t > _p_readUSBBackendFirmwareDump (uint32_t length);
        public:
        /// read data from the UVC Backend ROM
        ///   
        /// read data from the UVC Backend ROM. DepthNode::startUSBBackendFirmwareDump should be called prior to 
        /// read data from the UVC Backend ROM. Once the data has been written DepthNode::stopUSBBackendFirmwareDump
        /// should be called.
        ///
        /// \param length the length to be read
        /// \return the data read
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< uint8_t > readUSBBackendFirmwareDump (uint32_t length)
        {
            std::vector< uint8_t > retval = _p_readUSBBackendFirmwareDump(length).unmarshal();
            return retval;
        }
        /// stop UVC Backend firmware dump
        ///   
        /// stop UVC Backend firmware dump
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::ArgumentException some parameters of the structure are wrong
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void stopUSBBackendFirmwareDump ();
        /// set the status of the LED
        ///   
        /// set the status of the LED. When the color value is 0x00000000, the LED will be turned off.
        /// If the device does not support multiple colors, any color but 0x00000000 will turn the LED on.
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param color (HTML notation: 0x00RRGGBB)
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setLEDStatus (int32_t color);
        /// Create a DepthSense::RegisterValue
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \param i2cAddress the 7 bits i2cAddress of the device
        /// \param address the register address
        /// \param addressLength the length in bytes of the address
        /// \param valueLength the length in bytes of the value
        ///
        /// \return a DepthSense::RegisterValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::RegisterValue createRegisterValue (uint32_t i2cAddress, uint32_t address, uint8_t addressLength, uint8_t valueLength);
        /// Create a DepthSense::I2CArrayValue
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \param i2cAddress the 7 bits i2cAddress of the device
        ///
        /// \return a DepthSense::I2CArrayValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::I2CArrayValue createI2CArrayValue (uint32_t i2cAddress);
        /// Create a DepthSense::GPIOValue
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \param pin the GPIO pin
        ///
        /// \return a DepthSense::GPIOValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::GPIOValue createGPIOValue (uint32_t pin);
        /// Create a DepthSense::HardwareVersion value
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \return a DepthSense::HardwareVersion object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::HardwareVersion createHardwareVersionValue ();
        /// Create a DepthSense::SystemCalibrationValue value
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \return a DepthSense::SystemCalibrationValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemCalibrationValue createSystemCalibrationValue ();
        /// Create a DepthSense::SystemInfoValue value
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \return a DepthSense::SystemInfoValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemInfoValue createSystemInfoValue ();
        /// Create a DepthSense::SystemStateValue value
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \return a DepthSense::SystemStateValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemStateValue createSystemStateValue ();
        /// Create a DepthSense::Calibration value
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        ///
        /// \return a DepthSense::Calibration object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Calibration createCalibration ();
        /// Create a Parameter object value
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::ArgumentException the parameter is not available with this node or the object passed as argument was not created by this node
        ///
        /// \return a DepthSense::BaseValue object
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::BaseValue createParameterValue (DepthSense::ParameterType parameter);
        /// Write a DepthSense::BaseValue to the device
        ///
        /// Write a DepthSense::BaseValue to the device. The value will be written immediately in the
        /// device and appended to the end of the current active configuration. In the case the value is not
        /// of type DepthSense::RegisterValue, any previous write operation on the same parameter in the currently
        /// active configuration will be removed from the active configuration.
        ///
        /// Note that DepthSense::GPIOValue values will not be appended to the active configuration.
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::ArgumentException the parameter is not available with this node or the object passed as argument was not created by this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void writeValue (DepthSense::BaseValue value);
        /// Read a DepthSense::BaseValue from the device
        ///
        /// Read a DepthSense::BaseValue from the device. If the value is a DepthSense::RegisterValue,
        /// the value will be read from the device. For all the other type of DepthSense::BaseValue,
        /// the value will be read from the current active configuration if the active configuration does
        /// not contain any DepthSense::RegisterValue, otherwise it will throw an exception.
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// or the value is not of type DepthSense::RegisterValue and the active configuration contains 
        /// values of type DepthSense::RegisterValue or the active configuration is not set
        /// \exception DepthSense::ArgumentException the parameter is not defined in the current active configuration or the parameter is not available with this node or the object passed as argument was not created by this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void readValue (DepthSense::BaseValue value);
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::BaseValue > _p_getLastUpdatedRegisters ();
        public:
        /// Get the list of the last updated registers
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        ///
        /// \return the array of RegisterValue that has been updated since the last call
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::BaseValue > getLastUpdatedRegisters ()
        {
            std::vector< DepthSense::BaseValue > retval = _p_getLastUpdatedRegisters().unmarshal();
            return retval;
        }
        /// Store a configuration in ROM
        ///
        /// Store a configuration in ROM. Any existing configuration
        /// having the same name will be overwritten. This operation is permitted if all the boards
        /// are present. This method has an immediate effect.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node, the configuration is read only or some boards are missing
        /// \exception DepthSense::IOException the operation failed because of an I/O error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::ArgumentException the name is invalid, the commands to be saved contains at least one invalid command or the object passed as argument was not created by this node
        ///
        /// \param name the name of the configuration to be given to the configuration
        /// \param value the SystemStateValue to be saved
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void storeConfiguration (const char* name, DepthSense::SystemStateValue value);
        /// Store a calibration in ROM
        ///
        /// Store a calibration in ROM. Any existing configuration
        /// having the same name will be overwritten. This operation is permitted if all the boards
        /// are present. This method has an immediate effect. The configuration the calibration refers to must be already saved
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node, the configuration is read only or
        /// the active configuration is invalid or some boards are missing
        /// \exception DepthSense::IOException the operation failed because of an I/O error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::ArgumentException the name is invalid or the object passed as argument was not created by this node
        ///
        /// \param name the name of the configuration to be given to the configuration
        /// \param calibration the calibration to be saved
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void storeCalibration (const char* name, DepthSense::Calibration calibration);
        /// Delete a configuration from the device ROM
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the configuration is read only
        /// \exception DepthSense::ArgumentException the configuration name is invalid
        /// \exception DepthSense::IOException the operation failed because of an I/O error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        ///
        /// \param name the name of the configuration to be removed
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void removeConfiguration (const char* name);
        /// Return the configuration for a given name
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::ArgumentException the name doesn't match any known configuration
        ///
        /// \param name the name of the configuration to be returned
        /// \return the SystemStateValue for the given configuration name
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemStateValue getConfigurationByName (const char* name);
        /// Return the calibration for a given name
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::ArgumentException the name doesn't match any known configuration
        ///
        /// \param name the name of the configuration to be returned
        /// \return the Calibration for the given configuration name
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Calibration getCalibrationByName (const char* name);
        private:
        DEPTHSENSE_API void _p_writeTOFControllerFirmware (::DSI::Vector< uint8_t > data, bool resetInternalState);
        public:
        /// Write the TOF Controller Firmware
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the node is already streaming
        /// \exception DepthSense::IOException the operation failed because of an I/O error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        ///
        /// \param data the data to be written to the TOF Controller ROM
        /// \param resetInternalState tells whether the internal state of DSSDK should be reset or not
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void writeTOFControllerFirmware (std::vector< uint8_t > data, bool resetInternalState)
        {
            ::DSI::Vector< uint8_t > _p_data = DSI::Vector< uint8_t >::marshal(data);
            _p_writeTOFControllerFirmware(_p_data, resetInternalState);
        }
        /// Reset the device
        ///
        /// Reset the device and reload the default configuration
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported by this node
        /// \exception DepthSense::IOException the operation failed because of an I/O error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void resetDevice ();
        /// Set the read only flag of a configuration in ROM
        ///
        /// Set the read only flag of a configuration in ROM
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported by this node
        /// \exception DepthSense::IOException the operation failed because of an I/O error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::ArgumentException the name doesn't match any known configuration
        ///
        /// \param name the name of the configuration
        /// \param value whether the configuration should be read only or not
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfigurationReadOnly (const char* name, bool value);
        /// The PRV number of the camera
        ///
        /// The DepthNode::prvNumber property specifies the PRV number of the camera.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property uint32_t prvNumber;
        #endif
        /// Gets the value of the DepthNode::prvNumber property
        ///
        /// Gets the value of the DepthNode::prvNumber property.
        ///
        /// The DepthNode::prvNumber property specifies the PRV number of the camera.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::prvNumber property
        ///
        /// \sa setPrvNumber()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getPrvNumber ();
        /// Sets the value of the DepthNode::prvNumber property
        ///
        /// Sets the value of the DepthNode::prvNumber property.
        ///
        /// The DepthNode::prvNumber property specifies the PRV number of the camera.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getPrvNumber(), prvNumberIsReadOnly()
        ///
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setPrvNumber (uint32_t value);
        /// Checks whether property DepthNode::prvNumber is read-only
        ///
        /// Checks whether property DepthNode::prvNumber is read-only.
        ///
        /// The DepthNode::prvNumber property specifies the PRV number of the camera.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::prvNumber is read-only
        ///
        /// \sa setPrvNumber()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool prvNumberIsReadOnly ();
        /// Set the type of coordinate system to be used
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::CoordinateSystemType coordinateSystemType;
        #endif
        /// Gets the value of the DepthNode::coordinateSystemType property
        ///
        /// Gets the value of the DepthNode::coordinateSystemType property.
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::coordinateSystemType property
        ///
        /// \sa setCoordinateSystemType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::CoordinateSystemType getCoordinateSystemType ();
        /// Sets the value of the DepthNode::coordinateSystemType property
        ///
        /// Sets the value of the DepthNode::coordinateSystemType property.
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getCoordinateSystemType(), coordinateSystemTypeIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCoordinateSystemType (DepthSense::CoordinateSystemType value);
        /// Checks whether property DepthNode::coordinateSystemType is read-only
        ///
        /// Checks whether property DepthNode::coordinateSystemType is read-only.
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::coordinateSystemType is read-only
        ///
        /// \sa setCoordinateSystemType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool coordinateSystemTypeIsReadOnly ();
        /// Whether to enable confidence map computation
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableConfidenceMap;
        #endif
        /// Gets the value of the DepthNode::enableConfidenceMap property
        ///
        /// Gets the value of the DepthNode::enableConfidenceMap property.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableConfidenceMap property
        ///
        /// \sa setEnableConfidenceMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableConfidenceMap ();
        /// Sets the value of the DepthNode::enableConfidenceMap property
        ///
        /// Sets the value of the DepthNode::enableConfidenceMap property.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableConfidenceMap(), enableConfidenceMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableConfidenceMap (bool value);
        /// Checks whether property DepthNode::enableConfidenceMap is read-only
        ///
        /// Checks whether property DepthNode::enableConfidenceMap is read-only.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableConfidenceMap is read-only
        ///
        /// \sa setEnableConfidenceMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableConfidenceMapIsReadOnly ();
        /// Whether to enable phase map computation
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enablePhaseMap;
        #endif
        /// Gets the value of the DepthNode::enablePhaseMap property
        ///
        /// Gets the value of the DepthNode::enablePhaseMap property.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enablePhaseMap property
        ///
        /// \sa setEnablePhaseMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnablePhaseMap ();
        /// Sets the value of the DepthNode::enablePhaseMap property
        ///
        /// Sets the value of the DepthNode::enablePhaseMap property.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnablePhaseMap(), enablePhaseMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnablePhaseMap (bool value);
        /// Checks whether property DepthNode::enablePhaseMap is read-only
        ///
        /// Checks whether property DepthNode::enablePhaseMap is read-only.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enablePhaseMap is read-only
        ///
        /// \sa setEnablePhaseMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enablePhaseMapIsReadOnly ();
        /// Whether to enable fixed point depth map computation
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDepthMap;
        #endif
        /// Gets the value of the DepthNode::enableDepthMap property
        ///
        /// Gets the value of the DepthNode::enableDepthMap property.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDepthMap property
        ///
        /// \sa setEnableDepthMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDepthMap ();
        /// Sets the value of the DepthNode::enableDepthMap property
        ///
        /// Sets the value of the DepthNode::enableDepthMap property.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDepthMap(), enableDepthMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDepthMap (bool value);
        /// Checks whether property DepthNode::enableDepthMap is read-only
        ///
        /// Checks whether property DepthNode::enableDepthMap is read-only.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDepthMap is read-only
        ///
        /// \sa setEnableDepthMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDepthMapIsReadOnly ();
        /// Whether to enable floating point depth map computation
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDepthMapFloatingPoint;
        #endif
        /// Gets the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// Gets the value of the DepthNode::enableDepthMapFloatingPoint property.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// \sa setEnableDepthMapFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDepthMapFloatingPoint ();
        /// Sets the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// Sets the value of the DepthNode::enableDepthMapFloatingPoint property.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDepthMapFloatingPoint(), enableDepthMapFloatingPointIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDepthMapFloatingPoint (bool value);
        /// Checks whether property DepthNode::enableDepthMapFloatingPoint is read-only
        ///
        /// Checks whether property DepthNode::enableDepthMapFloatingPoint is read-only.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDepthMapFloatingPoint is read-only
        ///
        /// \sa setEnableDepthMapFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDepthMapFloatingPointIsReadOnly ();
        /// Whether to enable fixed point vertices computation
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableVertices;
        #endif
        /// Gets the value of the DepthNode::enableVertices property
        ///
        /// Gets the value of the DepthNode::enableVertices property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableVertices property
        ///
        /// \sa setEnableVertices()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableVertices ();
        /// Sets the value of the DepthNode::enableVertices property
        ///
        /// Sets the value of the DepthNode::enableVertices property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableVertices(), enableVerticesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableVertices (bool value);
        /// Checks whether property DepthNode::enableVertices is read-only
        ///
        /// Checks whether property DepthNode::enableVertices is read-only.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableVertices is read-only
        ///
        /// \sa setEnableVertices()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableVerticesIsReadOnly ();
        /// Whether to enable floating point vertices computation
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableVerticesFloatingPoint;
        #endif
        /// Gets the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// Gets the value of the DepthNode::enableVerticesFloatingPoint property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// \sa setEnableVerticesFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableVerticesFloatingPoint ();
        /// Sets the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// Sets the value of the DepthNode::enableVerticesFloatingPoint property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableVerticesFloatingPoint(), enableVerticesFloatingPointIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableVerticesFloatingPoint (bool value);
        /// Checks whether property DepthNode::enableVerticesFloatingPoint is read-only
        ///
        /// Checks whether property DepthNode::enableVerticesFloatingPoint is read-only.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableVerticesFloatingPoint is read-only
        ///
        /// \sa setEnableVerticesFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableVerticesFloatingPointIsReadOnly ();
        /// Whether the depth map is the XYZ coordinates as a planar representation or only the Z coordinate
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool depthMap3Planes;
        #endif
        /// Gets the value of the DepthNode::depthMap3Planes property
        ///
        /// Gets the value of the DepthNode::depthMap3Planes property.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::depthMap3Planes property
        ///
        /// \sa setDepthMap3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthMap3Planes ();
        /// Sets the value of the DepthNode::depthMap3Planes property
        ///
        /// Sets the value of the DepthNode::depthMap3Planes property.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthMap3Planes(), depthMap3PlanesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthMap3Planes (bool value);
        /// Checks whether property DepthNode::depthMap3Planes is read-only
        ///
        /// Checks whether property DepthNode::depthMap3Planes is read-only.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::depthMap3Planes is read-only
        ///
        /// \sa setDepthMap3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthMap3PlanesIsReadOnly ();
        /// Whether the floating point depth map is the XYZ coordinates as a planar representation or only the Z coordinate
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool depthMapFloatingPoint3Planes;
        #endif
        /// Gets the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// Gets the value of the DepthNode::depthMapFloatingPoint3Planes property.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// \sa setDepthMapFloatingPoint3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthMapFloatingPoint3Planes ();
        /// Sets the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// Sets the value of the DepthNode::depthMapFloatingPoint3Planes property.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthMapFloatingPoint3Planes(), depthMapFloatingPoint3PlanesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthMapFloatingPoint3Planes (bool value);
        /// Checks whether property DepthNode::depthMapFloatingPoint3Planes is read-only
        ///
        /// Checks whether property DepthNode::depthMapFloatingPoint3Planes is read-only.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::depthMapFloatingPoint3Planes is read-only
        ///
        /// \sa setDepthMapFloatingPoint3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthMapFloatingPoint3PlanesIsReadOnly ();
        /// Whether to enable UV map computation
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableUvMap;
        #endif
        /// Gets the value of the DepthNode::enableUvMap property
        ///
        /// Gets the value of the DepthNode::enableUvMap property.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableUvMap property
        ///
        /// \sa setEnableUvMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableUvMap ();
        /// Sets the value of the DepthNode::enableUvMap property
        ///
        /// Sets the value of the DepthNode::enableUvMap property.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableUvMap(), enableUvMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableUvMap (bool value);
        /// Checks whether property DepthNode::enableUvMap is read-only
        ///
        /// Checks whether property DepthNode::enableUvMap is read-only.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableUvMap is read-only
        ///
        /// \sa setEnableUvMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableUvMapIsReadOnly ();
        /// Whether to enable the accelerometer data
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableAccelerometer;
        #endif
        /// Gets the value of the DepthNode::enableAccelerometer property
        ///
        /// Gets the value of the DepthNode::enableAccelerometer property.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableAccelerometer property
        ///
        /// \sa setEnableAccelerometer()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableAccelerometer ();
        /// Sets the value of the DepthNode::enableAccelerometer property
        ///
        /// Sets the value of the DepthNode::enableAccelerometer property.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableAccelerometer(), enableAccelerometerIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableAccelerometer (bool value);
        /// Checks whether property DepthNode::enableAccelerometer is read-only
        ///
        /// Checks whether property DepthNode::enableAccelerometer is read-only.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableAccelerometer is read-only
        ///
        /// \sa setEnableAccelerometer()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableAccelerometerIsReadOnly ();
        #ifdef DEPTHSENSE_DOC
        @property bool _noFan;
        #endif
        /// Gets the value of the DepthNode::_noFan property
        ///
        /// Gets the value of the DepthNode::_noFan property.
        ///
        /// \return the value of the DepthNode::_noFan property
        ///
        /// \sa set_noFan()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool get_noFan ();
        /// Sets the value of the DepthNode::_noFan property
        ///
        /// Sets the value of the DepthNode::_noFan property.
        ///
        /// \param value the value to set
        ///
        /// \sa get_noFan(), _noFanIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void set_noFan (bool value);
        /// Checks whether property DepthNode::_noFan is read-only
        ///
        /// Checks whether property DepthNode::_noFan is read-only.
        ///
        /// \return whether property DepthNode::_noFan is read-only
        ///
        /// \sa set_noFan()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool _noFanIsReadOnly ();
        /// Specify the confidence threshold
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t confidenceThreshold;
        #endif
        /// Gets the value of the DepthNode::confidenceThreshold property
        ///
        /// Gets the value of the DepthNode::confidenceThreshold property.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::confidenceThreshold property
        ///
        /// \sa setConfidenceThreshold()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getConfidenceThreshold ();
        /// Sets the value of the DepthNode::confidenceThreshold property
        ///
        /// Sets the value of the DepthNode::confidenceThreshold property.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getConfidenceThreshold(), confidenceThresholdIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfidenceThreshold (int32_t value);
        /// Checks whether property DepthNode::confidenceThreshold is read-only
        ///
        /// Checks whether property DepthNode::confidenceThreshold is read-only.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::confidenceThreshold is read-only
        ///
        /// \sa setConfidenceThreshold()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool confidenceThresholdIsReadOnly ();
        /// Specify the illumination level
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t illuminationLevel;
        #endif
        /// Gets the value of the DepthNode::illuminationLevel property
        ///
        /// Gets the value of the DepthNode::illuminationLevel property.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::illuminationLevel property
        ///
        /// \sa setIlluminationLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getIlluminationLevel ();
        /// Sets the value of the DepthNode::illuminationLevel property
        ///
        /// Sets the value of the DepthNode::illuminationLevel property.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getIlluminationLevel(), illuminationLevelIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException the property is not supported by the node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setIlluminationLevel (int32_t value);
        /// Checks whether property DepthNode::illuminationLevel is read-only
        ///
        /// Checks whether property DepthNode::illuminationLevel is read-only.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::illuminationLevel is read-only
        ///
        /// \sa setIlluminationLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool illuminationLevelIsReadOnly ();
        /// Whether to enable denoising
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDenoising;
        #endif
        /// Gets the value of the DepthNode::enableDenoising property
        ///
        /// Gets the value of the DepthNode::enableDenoising property.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDenoising property
        ///
        /// \sa setEnableDenoising()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDenoising ();
        /// Sets the value of the DepthNode::enableDenoising property
        ///
        /// Sets the value of the DepthNode::enableDenoising property.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDenoising(), enableDenoisingIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDenoising (bool value);
        /// Checks whether property DepthNode::enableDenoising is read-only
        ///
        /// Checks whether property DepthNode::enableDenoising is read-only.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDenoising is read-only
        ///
        /// \sa setEnableDenoising()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDenoisingIsReadOnly ();
        /// The node configuration
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::DepthNode::Configuration configuration;
        #endif
        /// Gets the value of the DepthNode::configuration property
        ///
        /// Gets the value of the DepthNode::configuration property.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::Configuration getConfiguration ();
        /// Sets the value of the DepthNode::configuration property
        ///
        /// Sets the value of the DepthNode::configuration property.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::DepthNode::Configuration value);
        /// Checks whether property DepthNode::configuration is read-only
        ///
        /// Checks whether property DepthNode::configuration is read-only.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The DepthNode::configurations property specifies the list
        /// of supported node configurations.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::DepthNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::DepthNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the DepthNode::configurations property
        ///
        /// Gets the value of the DepthNode::configurations property.
        ///
        ///
        /// \return the value of the DepthNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::DepthNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::DepthNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The depth sensor range
        ///
        /// The DepthNode::range property specifies the range of the
        /// depth sensor, expressed in meters.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        #ifdef DEPTHSENSE_DOC
        @property(readonly) float range;
        #endif
        /// Gets the value of the DepthNode::range property
        ///
        /// Gets the value of the DepthNode::range property.
        ///
        /// The DepthNode::range property specifies the range of the
        /// depth sensor, expressed in meters.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        ///
        /// \return the value of the DepthNode::range property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getRange ();
        /// The IMU firmware version
        ///
        /// The DepthNode::imuFwVersion property specifies the version of the current IMU board.
        /// The version is as given by the IMU (See IMU meta data documentation for more details).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t imuFwVersion;
        #endif
        /// Gets the value of the DepthNode::imuFwVersion property
        ///
        /// Gets the value of the DepthNode::imuFwVersion property.
        ///
        /// The DepthNode::imuFwVersion property specifies the version of the current IMU board.
        /// The version is as given by the IMU (See IMU meta data documentation for more details).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::imuFwVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getImuFwVersion ();
        /// The list of IMU board leds color
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property std::vector< uint32_t > imuLedsColor;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< uint32_t > _p_getImuLedsColor ();
        public:
        /// Gets the value of the DepthNode::imuLedsColor property
        ///
        /// Gets the value of the DepthNode::imuLedsColor property.
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::imuLedsColor property
        ///
        /// \sa setImuLedsColor()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< uint32_t > getImuLedsColor ()
        {
            std::vector< uint32_t > retval = _p_getImuLedsColor().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setImuLedsColor (::DSI::Vector< uint32_t > value);
        public:
        /// Sets the value of the DepthNode::imuLedsColor property
        ///
        /// Sets the value of the DepthNode::imuLedsColor property.
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getImuLedsColor(), imuLedsColorIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException the property is not supported by the node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setImuLedsColor (std::vector< uint32_t > value)
        {
            ::DSI::Vector< uint32_t > _p_value = DSI::Vector< uint32_t >::marshal(value);
            _p_setImuLedsColor(_p_value);
        }
        /// Checks whether property DepthNode::imuLedsColor is read-only
        ///
        /// Checks whether property DepthNode::imuLedsColor is read-only.
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::imuLedsColor is read-only
        ///
        /// \sa setImuLedsColor()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool imuLedsColorIsReadOnly ();
        /// Return the list of name of known configurations
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< std::string > configurationList;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< ::DSI::String > _p_getConfigurationList ();
        public:
        /// Gets the value of the DepthNode::configurationList property
        ///
        /// Gets the value of the DepthNode::configurationList property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        ///
        /// \return the value of the DepthNode::configurationList property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< std::string > getConfigurationList ()
        {
            ::DSI::Vector< ::DSI::String > _tmp92 = _p_getConfigurationList();
            std::vector< std::string > retval;
            int32_t _tmp93 = (int32_t) _tmp92.size();
            for (int _i = 0; _i < _tmp93; _i++)
            {
                retval.push_back(_tmp92[_i].unmarshal());
            }
            return retval;
        }
        /// Return the name of the current active configuration
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string configurationName;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getConfigurationName ();
        public:
        /// Gets the value of the DepthNode::configurationName property
        ///
        /// Gets the value of the DepthNode::configurationName property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        ///
        /// \return the value of the DepthNode::configurationName property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getConfigurationName ()
        {
            std::string retval = _p_getConfigurationName().unmarshal();
            return retval;
        }
        /// The high sensitivity mode
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t highSensitivityMode;
        #endif
        /// Gets the value of the DepthNode::highSensitivityMode property
        ///
        /// Gets the value of the DepthNode::highSensitivityMode property.
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::highSensitivityMode property
        ///
        /// \sa setHighSensitivityMode()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHighSensitivityMode ();
        /// Sets the value of the DepthNode::highSensitivityMode property
        ///
        /// Sets the value of the DepthNode::highSensitivityMode property.
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHighSensitivityMode(), highSensitivityModeIsReadOnly()
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the value passed as argument is not valid
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHighSensitivityMode (int32_t value);
        /// Checks whether property DepthNode::highSensitivityMode is read-only
        ///
        /// Checks whether property DepthNode::highSensitivityMode is read-only.
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::highSensitivityMode is read-only
        ///
        /// \sa setHighSensitivityMode()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool highSensitivityModeIsReadOnly ();
        /// Specify the high sensitivity mode parameter 1
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t highSensitivityModeParameter1;
        #endif
        /// Gets the value of the DepthNode::highSensitivityModeParameter1 property
        ///
        /// Gets the value of the DepthNode::highSensitivityModeParameter1 property.
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::highSensitivityModeParameter1 property
        ///
        /// \sa setHighSensitivityModeParameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHighSensitivityModeParameter1 ();
        /// Sets the value of the DepthNode::highSensitivityModeParameter1 property
        ///
        /// Sets the value of the DepthNode::highSensitivityModeParameter1 property.
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHighSensitivityModeParameter1(), highSensitivityModeParameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHighSensitivityModeParameter1 (int32_t value);
        /// Checks whether property DepthNode::highSensitivityModeParameter1 is read-only
        ///
        /// Checks whether property DepthNode::highSensitivityModeParameter1 is read-only.
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::highSensitivityModeParameter1 is read-only
        ///
        /// \sa setHighSensitivityModeParameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool highSensitivityModeParameter1IsReadOnly ();
        /// Specify the high sensitivity mode parameter 2
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t highSensitivityModeParameter2;
        #endif
        /// Gets the value of the DepthNode::highSensitivityModeParameter2 property
        ///
        /// Gets the value of the DepthNode::highSensitivityModeParameter2 property.
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::highSensitivityModeParameter2 property
        ///
        /// \sa setHighSensitivityModeParameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHighSensitivityModeParameter2 ();
        /// Sets the value of the DepthNode::highSensitivityModeParameter2 property
        ///
        /// Sets the value of the DepthNode::highSensitivityModeParameter2 property.
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHighSensitivityModeParameter2(), highSensitivityModeParameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHighSensitivityModeParameter2 (int32_t value);
        /// Checks whether property DepthNode::highSensitivityModeParameter2 is read-only
        ///
        /// Checks whether property DepthNode::highSensitivityModeParameter2 is read-only.
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::highSensitivityModeParameter2 is read-only
        ///
        /// \sa setHighSensitivityModeParameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool highSensitivityModeParameter2IsReadOnly ();
        /// The dealiasing calibration mode
        ///
        /// The DepthNode::dealiasingCalibrationMode property controls the
        /// dealiasing calibration mode to apply on the device
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t dealiasingCalibrationMode;
        #endif
        /// Gets the value of the DepthNode::dealiasingCalibrationMode property
        ///
        /// Gets the value of the DepthNode::dealiasingCalibrationMode property.
        ///
        /// The DepthNode::dealiasingCalibrationMode property controls the
        /// dealiasing calibration mode to apply on the device
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::dealiasingCalibrationMode property
        ///
        /// \sa setDealiasingCalibrationMode()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getDealiasingCalibrationMode ();
        /// Sets the value of the DepthNode::dealiasingCalibrationMode property
        ///
        /// Sets the value of the DepthNode::dealiasingCalibrationMode property.
        ///
        /// The DepthNode::dealiasingCalibrationMode property controls the
        /// dealiasing calibration mode to apply on the device
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDealiasingCalibrationMode(), dealiasingCalibrationModeIsReadOnly()
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the value passed as argument is not valid
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDealiasingCalibrationMode (int32_t value);
        /// Checks whether property DepthNode::dealiasingCalibrationMode is read-only
        ///
        /// Checks whether property DepthNode::dealiasingCalibrationMode is read-only.
        ///
        /// The DepthNode::dealiasingCalibrationMode property controls the
        /// dealiasing calibration mode to apply on the device
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::dealiasingCalibrationMode is read-only
        ///
        /// \sa setDealiasingCalibrationMode()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool dealiasingCalibrationModeIsReadOnly ();
        /// Whether to enable extra illumination
        ///
        /// The DepthNode::illuminationBoost property controls whether
        /// addition lasers must be activated for boosted illumination.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool illuminationBoost;
        #endif
        /// Gets the value of the DepthNode::illuminationBoost property
        ///
        /// Gets the value of the DepthNode::illuminationBoost property.
        ///
        /// The DepthNode::illuminationBoost property controls whether
        /// addition lasers must be activated for boosted illumination.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::illuminationBoost property
        ///
        /// \sa setIlluminationBoost()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getIlluminationBoost ();
        /// Sets the value of the DepthNode::illuminationBoost property
        ///
        /// Sets the value of the DepthNode::illuminationBoost property.
        ///
        /// The DepthNode::illuminationBoost property controls whether
        /// addition lasers must be activated for boosted illumination.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getIlluminationBoost(), illuminationBoostIsReadOnly()
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setIlluminationBoost (bool value);
        /// Checks whether property DepthNode::illuminationBoost is read-only
        ///
        /// Checks whether property DepthNode::illuminationBoost is read-only.
        ///
        /// The DepthNode::illuminationBoost property controls whether
        /// addition lasers must be activated for boosted illumination.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::illuminationBoost is read-only
        ///
        /// \sa setIlluminationBoost()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool illuminationBoostIsReadOnly ();
        /// Whether to enable auto-exposure
        ///
        /// The DepthNode::enableAutoExposure property controls whether
        /// the auto-exposure feature must be activated
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableAutoExposure;
        #endif
        /// Gets the value of the DepthNode::enableAutoExposure property
        ///
        /// Gets the value of the DepthNode::enableAutoExposure property.
        ///
        /// The DepthNode::enableAutoExposure property controls whether
        /// the auto-exposure feature must be activated
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableAutoExposure property
        ///
        /// \sa setEnableAutoExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableAutoExposure ();
        /// Sets the value of the DepthNode::enableAutoExposure property
        ///
        /// Sets the value of the DepthNode::enableAutoExposure property.
        ///
        /// The DepthNode::enableAutoExposure property controls whether
        /// the auto-exposure feature must be activated
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableAutoExposure(), enableAutoExposureIsReadOnly()
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableAutoExposure (bool value);
        /// Checks whether property DepthNode::enableAutoExposure is read-only
        ///
        /// Checks whether property DepthNode::enableAutoExposure is read-only.
        ///
        /// The DepthNode::enableAutoExposure property controls whether
        /// the auto-exposure feature must be activated
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableAutoExposure is read-only
        ///
        /// \sa setEnableAutoExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableAutoExposureIsReadOnly ();
        /// Whether to enable raw data
        ///
        /// The DepthNode::enableRawData property specifies whether
        /// to enable raw data and make it available
        /// through the \c rawData argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableRawData;
        #endif
        /// Gets the value of the DepthNode::enableRawData property
        ///
        /// Gets the value of the DepthNode::enableRawData property.
        ///
        /// The DepthNode::enableRawData property specifies whether
        /// to enable raw data and make it available
        /// through the \c rawData argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableRawData property
        ///
        /// \sa setEnableRawData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableRawData ();
        /// Sets the value of the DepthNode::enableRawData property
        ///
        /// Sets the value of the DepthNode::enableRawData property.
        ///
        /// The DepthNode::enableRawData property specifies whether
        /// to enable raw data and make it available
        /// through the \c rawData argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableRawData(), enableRawDataIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableRawData (bool value);
        /// Checks whether property DepthNode::enableRawData is read-only
        ///
        /// Checks whether property DepthNode::enableRawData is read-only.
        ///
        /// The DepthNode::enableRawData property specifies whether
        /// to enable raw data and make it available
        /// through the \c rawData argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableRawData is read-only
        ///
        /// \sa setEnableRawData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableRawDataIsReadOnly ();
        /// Whether to enable ambient map
        ///
        /// The DepthNode::enableAmbientMap property specifies whether
        /// to enable ambient data and make it available
        /// through the \c ambientMap argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported
        #ifdef DEPTHSENSE_DOC
        @property bool enableAmbientMap;
        #endif
        /// Gets the value of the DepthNode::enableAmbientMap property
        ///
        /// Gets the value of the DepthNode::enableAmbientMap property.
        ///
        /// The DepthNode::enableAmbientMap property specifies whether
        /// to enable ambient data and make it available
        /// through the \c ambientMap argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported
        ///
        /// \return the value of the DepthNode::enableAmbientMap property
        ///
        /// \sa setEnableAmbientMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableAmbientMap ();
        /// Sets the value of the DepthNode::enableAmbientMap property
        ///
        /// Sets the value of the DepthNode::enableAmbientMap property.
        ///
        /// The DepthNode::enableAmbientMap property specifies whether
        /// to enable ambient data and make it available
        /// through the \c ambientMap argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableAmbientMap(), enableAmbientMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableAmbientMap (bool value);
        /// Checks whether property DepthNode::enableAmbientMap is read-only
        ///
        /// Checks whether property DepthNode::enableAmbientMap is read-only.
        ///
        /// The DepthNode::enableAmbientMap property specifies whether
        /// to enable ambient data and make it available
        /// through the \c ambientMap argument of the \c
        /// newSampleReceivedEx event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported
        ///
        /// \return whether property DepthNode::enableAmbientMap is read-only
        ///
        /// \sa setEnableAmbientMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableAmbientMapIsReadOnly ();
        /// Whether to disable auto-configuration
        ///
        /// Specifies whether to disable the auto-configuration of the
        /// depth node when starting the streaming.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool disableAutoConfiguration;
        #endif
        /// Gets the value of the DepthNode::disableAutoConfiguration property
        ///
        /// Gets the value of the DepthNode::disableAutoConfiguration property.
        ///
        /// Specifies whether to disable the auto-configuration of the
        /// depth node when starting the streaming.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::disableAutoConfiguration property
        ///
        /// \sa setDisableAutoConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDisableAutoConfiguration ();
        /// Sets the value of the DepthNode::disableAutoConfiguration property
        ///
        /// Sets the value of the DepthNode::disableAutoConfiguration property.
        ///
        /// Specifies whether to disable the auto-configuration of the
        /// depth node when starting the streaming.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDisableAutoConfiguration(), disableAutoConfigurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDisableAutoConfiguration (bool value);
        /// Checks whether property DepthNode::disableAutoConfiguration is read-only
        ///
        /// Checks whether property DepthNode::disableAutoConfiguration is read-only.
        ///
        /// Specifies whether to disable the auto-configuration of the
        /// depth node when starting the streaming.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::disableAutoConfiguration is read-only
        ///
        /// \sa setDisableAutoConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool disableAutoConfigurationIsReadOnly ();
        /// The DVP frame format of the UVC backend
        ///
        /// Specifies the DVP frame format of the UVC Backend. This
        /// property should be set before starting the streaming, and
        /// will be ignored unless the \c disableAutoConfiguration
        /// property is set to true.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::FrameFormat dvpFrameFormat;
        #endif
        /// Gets the value of the DepthNode::dvpFrameFormat property
        ///
        /// Gets the value of the DepthNode::dvpFrameFormat property.
        ///
        /// Specifies the DVP frame format of the UVC Backend. This
        /// property should be set before starting the streaming, and
        /// will be ignored unless the \c disableAutoConfiguration
        /// property is set to true.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::dvpFrameFormat property
        ///
        /// \sa setDvpFrameFormat()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::FrameFormat getDvpFrameFormat ();
        /// Sets the value of the DepthNode::dvpFrameFormat property
        ///
        /// Sets the value of the DepthNode::dvpFrameFormat property.
        ///
        /// Specifies the DVP frame format of the UVC Backend. This
        /// property should be set before starting the streaming, and
        /// will be ignored unless the \c disableAutoConfiguration
        /// property is set to true.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDvpFrameFormat(), dvpFrameFormatIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node, or the maintenace password has not been set
        /// \exception DepthSense::ArgumentException the provided frame format is invalid
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDvpFrameFormat (DepthSense::FrameFormat value);
        /// Checks whether property DepthNode::dvpFrameFormat is read-only
        ///
        /// Checks whether property DepthNode::dvpFrameFormat is read-only.
        ///
        /// Specifies the DVP frame format of the UVC Backend. This
        /// property should be set before starting the streaming, and
        /// will be ignored unless the \c disableAutoConfiguration
        /// property is set to true.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::dvpFrameFormat is read-only
        ///
        /// \sa setDvpFrameFormat()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool dvpFrameFormatIsReadOnly ();
        #ifdef DEPTHSENSE_DOC
        @property std::string maintenancePassword;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getMaintenancePassword ();
        public:
        /// Gets the value of the DepthNode::maintenancePassword property
        ///
        /// Gets the value of the DepthNode::maintenancePassword property.
        ///
        /// \return the value of the DepthNode::maintenancePassword property
        ///
        /// \sa setMaintenancePassword()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getMaintenancePassword ()
        {
            std::string retval = _p_getMaintenancePassword().unmarshal();
            return retval;
        }
        /// Sets the value of the DepthNode::maintenancePassword property
        ///
        /// Sets the value of the DepthNode::maintenancePassword property.
        ///
        /// \param value the value to set
        ///
        /// \sa getMaintenancePassword(), maintenancePasswordIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setMaintenancePassword (const char* value);
        /// Checks whether property DepthNode::maintenancePassword is read-only
        ///
        /// Checks whether property DepthNode::maintenancePassword is read-only.
        ///
        /// \return whether property DepthNode::maintenancePassword is read-only
        ///
        /// \sa setMaintenancePassword()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool maintenancePasswordIsReadOnly ();
        ///
        /// The DepthNode::enableOverheatingDisconnection property specifies
        /// whether to enable the camera disconnection when overheating is detected
        /// By default, this property is enabled, but can be changed through the \c argument \c
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableOverheatingDisconnection;
        #endif
        /// Gets the value of the DepthNode::enableOverheatingDisconnection property
        ///
        /// Gets the value of the DepthNode::enableOverheatingDisconnection property.
        ///
        ///
        /// \return the value of the DepthNode::enableOverheatingDisconnection property
        ///
        /// \sa setEnableOverheatingDisconnection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableOverheatingDisconnection ();
        /// Sets the value of the DepthNode::enableOverheatingDisconnection property
        ///
        /// Sets the value of the DepthNode::enableOverheatingDisconnection property.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableOverheatingDisconnection(), enableOverheatingDisconnectionIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableOverheatingDisconnection (bool value);
        /// Checks whether property DepthNode::enableOverheatingDisconnection is read-only
        ///
        /// Checks whether property DepthNode::enableOverheatingDisconnection is read-only.
        ///
        ///
        /// \return whether property DepthNode::enableOverheatingDisconnection is read-only
        ///
        /// \sa setEnableOverheatingDisconnection()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableOverheatingDisconnectionIsReadOnly ();
        /// The raw payload size per frame to be expected by the DepthSenseSDK backend
        ///
        /// The rawPayloadSizePerFrame property allows to set the expected payload size per frame by the DepthSenseSDK backend.
        /// The context must have control over the node and the \c disableAutoConfiguration property should be disabled in order
        /// to be able to set this property.
        /// 
        /// The payload size must be a multiple of 2 and not equal to 0.
        ///
        /// Setting this property will invalidate the current configuration. The original behavior can be restored
        /// by setting a configuration either through the \c DepthNode::Configuration property or the \c DepthNode::setConfigurationByName.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t rawPayloadSizePerFrame;
        #endif
        /// Gets the value of the DepthNode::rawPayloadSizePerFrame property
        ///
        /// Gets the value of the DepthNode::rawPayloadSizePerFrame property.
        ///
        /// The rawPayloadSizePerFrame property allows to set the expected payload size per frame by the DepthSenseSDK backend.
        /// The context must have control over the node and the \c disableAutoConfiguration property should be disabled in order
        /// to be able to set this property.
        /// 
        /// The payload size must be a multiple of 2 and not equal to 0.
        ///
        /// Setting this property will invalidate the current configuration. The original behavior can be restored
        /// by setting a configuration either through the \c DepthNode::Configuration property or the \c DepthNode::setConfigurationByName.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::rawPayloadSizePerFrame property
        ///
        /// \sa setRawPayloadSizePerFrame()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRawPayloadSizePerFrame ();
        /// Sets the value of the DepthNode::rawPayloadSizePerFrame property
        ///
        /// Sets the value of the DepthNode::rawPayloadSizePerFrame property.
        ///
        /// The rawPayloadSizePerFrame property allows to set the expected payload size per frame by the DepthSenseSDK backend.
        /// The context must have control over the node and the \c disableAutoConfiguration property should be disabled in order
        /// to be able to set this property.
        /// 
        /// The payload size must be a multiple of 2 and not equal to 0.
        ///
        /// Setting this property will invalidate the current configuration. The original behavior can be restored
        /// by setting a configuration either through the \c DepthNode::Configuration property or the \c DepthNode::setConfigurationByName.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getRawPayloadSizePerFrame(), rawPayloadSizePerFrameIsReadOnly()
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setRawPayloadSizePerFrame (int32_t value);
        /// Checks whether property DepthNode::rawPayloadSizePerFrame is read-only
        ///
        /// Checks whether property DepthNode::rawPayloadSizePerFrame is read-only.
        ///
        /// The rawPayloadSizePerFrame property allows to set the expected payload size per frame by the DepthSenseSDK backend.
        /// The context must have control over the node and the \c disableAutoConfiguration property should be disabled in order
        /// to be able to set this property.
        /// 
        /// The payload size must be a multiple of 2 and not equal to 0.
        ///
        /// Setting this property will invalidate the current configuration. The original behavior can be restored
        /// by setting a configuration either through the \c DepthNode::Configuration property or the \c DepthNode::setConfigurationByName.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::rawPayloadSizePerFrame is read-only
        ///
        /// \sa setRawPayloadSizePerFrame()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool rawPayloadSizePerFrameIsReadOnly ();
        /// The current SystemStateValue
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::SystemStateValue systemState;
        #endif
        /// Gets the value of the DepthNode::systemState property
        ///
        /// Gets the value of the DepthNode::systemState property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        ///
        /// \return the value of the DepthNode::systemState property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemStateValue getSystemState ();
        /// The current SystemCalibrationValue
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::SystemCalibrationValue systemCalibration;
        #endif
        /// Gets the value of the DepthNode::systemCalibration property
        ///
        /// Gets the value of the DepthNode::systemCalibration property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        ///
        /// \return the value of the DepthNode::systemCalibration property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemCalibrationValue getSystemCalibration ();
        /// The current SystemInfoValue
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::SystemInfoValue systemInfo;
        #endif
        /// Gets the value of the DepthNode::systemInfo property
        ///
        /// Gets the value of the DepthNode::systemInfo property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this node
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        ///
        /// \return the value of the DepthNode::systemInfo property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::SystemInfoValue getSystemInfo ();
        /// The currently active calibration
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the active configuration is not set
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::Calibration calibration;
        #endif
        /// Gets the value of the DepthNode::calibration property
        ///
        /// Gets the value of the DepthNode::calibration property.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the active configuration is not set
        ///
        /// \return the value of the DepthNode::calibration property
        ///
        /// \sa setCalibration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Calibration getCalibration ();
        /// Sets the value of the DepthNode::calibration property
        ///
        /// Sets the value of the DepthNode::calibration property.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the active configuration is not set
        ///
        /// \param value the value to set
        ///
        /// \sa getCalibration(), calibrationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the object passed as argument was not created by this node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCalibration (DepthSense::Calibration value);
        /// Checks whether property DepthNode::calibration is read-only
        ///
        /// Checks whether property DepthNode::calibration is read-only.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the active configuration is not set
        ///
        /// \return whether property DepthNode::calibration is read-only
        ///
        /// \sa setCalibration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool calibrationIsReadOnly ();
        /// The raw output mode of the TOF Controller
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::RawOutputMode rawOutputMode;
        #endif
        /// Gets the value of the DepthNode::rawOutputMode property
        ///
        /// Gets the value of the DepthNode::rawOutputMode property.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::rawOutputMode property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::RawOutputMode getRawOutputMode ();
        /// The version of the different hw components of the CDK
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::HardwareVersion hardwareVersion;
        #endif
        /// Gets the value of the DepthNode::hardwareVersion property
        ///
        /// Gets the value of the DepthNode::hardwareVersion property.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::hardwareVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::HardwareVersion getHardwareVersion ();
        /// The Region of Interest
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported by this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::RegionOfInterest regionOfInterest;
        #endif
        /// Gets the value of the DepthNode::regionOfInterest property
        ///
        /// Gets the value of the DepthNode::regionOfInterest property.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node or the feature is not supported by this node
        ///
        /// \return the value of the DepthNode::regionOfInterest property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::RegionOfInterest getRegionOfInterest ();
        /// Whether to enable filter 1
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter1;
        #endif
        /// Gets the value of the DepthNode::enableFilter1 property
        ///
        /// Gets the value of the DepthNode::enableFilter1 property.
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter1 property
        ///
        /// \sa setEnableFilter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter1 ();
        /// Sets the value of the DepthNode::enableFilter1 property
        ///
        /// Sets the value of the DepthNode::enableFilter1 property.
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter1(), enableFilter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter1 (bool value);
        /// Checks whether property DepthNode::enableFilter1 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter1 is read-only.
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter1 is read-only
        ///
        /// \sa setEnableFilter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter1IsReadOnly ();
        /// Whether to enable filter 2
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter2;
        #endif
        /// Gets the value of the DepthNode::enableFilter2 property
        ///
        /// Gets the value of the DepthNode::enableFilter2 property.
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter2 property
        ///
        /// \sa setEnableFilter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter2 ();
        /// Sets the value of the DepthNode::enableFilter2 property
        ///
        /// Sets the value of the DepthNode::enableFilter2 property.
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter2(), enableFilter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter2 (bool value);
        /// Checks whether property DepthNode::enableFilter2 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter2 is read-only.
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter2 is read-only
        ///
        /// \sa setEnableFilter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter2IsReadOnly ();
        /// Whether to enable filter 3
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter3;
        #endif
        /// Gets the value of the DepthNode::enableFilter3 property
        ///
        /// Gets the value of the DepthNode::enableFilter3 property.
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter3 property
        ///
        /// \sa setEnableFilter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter3 ();
        /// Sets the value of the DepthNode::enableFilter3 property
        ///
        /// Sets the value of the DepthNode::enableFilter3 property.
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter3(), enableFilter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter3 (bool value);
        /// Checks whether property DepthNode::enableFilter3 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter3 is read-only.
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter3 is read-only
        ///
        /// \sa setEnableFilter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter3IsReadOnly ();
        /// Whether to enable filter 4
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter4;
        #endif
        /// Gets the value of the DepthNode::enableFilter4 property
        ///
        /// Gets the value of the DepthNode::enableFilter4 property.
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter4 property
        ///
        /// \sa setEnableFilter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter4 ();
        /// Sets the value of the DepthNode::enableFilter4 property
        ///
        /// Sets the value of the DepthNode::enableFilter4 property.
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter4(), enableFilter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter4 (bool value);
        /// Checks whether property DepthNode::enableFilter4 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter4 is read-only.
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter4 is read-only
        ///
        /// \sa setEnableFilter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter4IsReadOnly ();
        /// Whether to enable filter 5
        ///
        /// Specifies whether to enable filter 5
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter5;
        #endif
        /// Gets the value of the DepthNode::enableFilter5 property
        ///
        /// Gets the value of the DepthNode::enableFilter5 property.
        ///
        /// Specifies whether to enable filter 5
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter5 property
        ///
        /// \sa setEnableFilter5()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter5 ();
        /// Sets the value of the DepthNode::enableFilter5 property
        ///
        /// Sets the value of the DepthNode::enableFilter5 property.
        ///
        /// Specifies whether to enable filter 5
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter5(), enableFilter5IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter5 (bool value);
        /// Checks whether property DepthNode::enableFilter5 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter5 is read-only.
        ///
        /// Specifies whether to enable filter 5
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter5 is read-only
        ///
        /// \sa setEnableFilter5()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter5IsReadOnly ();
        /// Whether to enable filter 6
        ///
        /// Specifies whether to enable filter 6
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter6;
        #endif
        /// Gets the value of the DepthNode::enableFilter6 property
        ///
        /// Gets the value of the DepthNode::enableFilter6 property.
        ///
        /// Specifies whether to enable filter 6
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter6 property
        ///
        /// \sa setEnableFilter6()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter6 ();
        /// Sets the value of the DepthNode::enableFilter6 property
        ///
        /// Sets the value of the DepthNode::enableFilter6 property.
        ///
        /// Specifies whether to enable filter 6
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter6(), enableFilter6IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter6 (bool value);
        /// Checks whether property DepthNode::enableFilter6 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter6 is read-only.
        ///
        /// Specifies whether to enable filter 6
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter6 is read-only
        ///
        /// \sa setEnableFilter6()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter6IsReadOnly ();
        /// Whether to enable filter 8
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter8;
        #endif
        /// Gets the value of the DepthNode::enableFilter8 property
        ///
        /// Gets the value of the DepthNode::enableFilter8 property.
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter8 property
        ///
        /// \sa setEnableFilter8()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter8 ();
        /// Sets the value of the DepthNode::enableFilter8 property
        ///
        /// Sets the value of the DepthNode::enableFilter8 property.
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter8(), enableFilter8IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter8 (bool value);
        /// Checks whether property DepthNode::enableFilter8 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter8 is read-only.
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter8 is read-only
        ///
        /// \sa setEnableFilter8()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter8IsReadOnly ();
        /// Whether to enable filter 9
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter9;
        #endif
        /// Gets the value of the DepthNode::enableFilter9 property
        ///
        /// Gets the value of the DepthNode::enableFilter9 property.
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter9 property
        ///
        /// \sa setEnableFilter9()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter9 ();
        /// Sets the value of the DepthNode::enableFilter9 property
        ///
        /// Sets the value of the DepthNode::enableFilter9 property.
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter9(), enableFilter9IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter9 (bool value);
        /// Checks whether property DepthNode::enableFilter9 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter9 is read-only.
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter9 is read-only
        ///
        /// \sa setEnableFilter9()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter9IsReadOnly ();
        /// Specify the parameter 1 of filter 1
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter1 property.
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter1 property
        ///
        /// \sa setFilter1Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter1 ();
        /// Sets the value of the DepthNode::filter1Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter1 property.
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter1(), filter1Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter1 is read-only.
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter1 is read-only
        ///
        /// \sa setFilter1Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 1
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter2 property.
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter2 property
        ///
        /// \sa setFilter1Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter2 ();
        /// Sets the value of the DepthNode::filter1Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter2 property.
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter2(), filter1Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter2 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter2 is read-only.
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter2 is read-only
        ///
        /// \sa setFilter1Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 1
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter3 property.
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter3 property
        ///
        /// \sa setFilter1Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter3 ();
        /// Sets the value of the DepthNode::filter1Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter3 property.
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter3(), filter1Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter3 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter3 is read-only.
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter3 is read-only
        ///
        /// \sa setFilter1Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 1
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter4 property.
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter4 property
        ///
        /// \sa setFilter1Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter4 ();
        /// Sets the value of the DepthNode::filter1Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter4 property.
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter4(), filter1Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter4 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter4 is read-only.
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter4 is read-only
        ///
        /// \sa setFilter1Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter4IsReadOnly ();
        /// Specify the parameter 1 of filter 2
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter2Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter2Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter2Parameter1 property.
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter2Parameter1 property
        ///
        /// \sa setFilter2Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter2Parameter1 ();
        /// Sets the value of the DepthNode::filter2Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter2Parameter1 property.
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter2Parameter1(), filter2Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter2Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter2Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter2Parameter1 is read-only.
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter2Parameter1 is read-only
        ///
        /// \sa setFilter2Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter2Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 3
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter3Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter3Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter3Parameter1 property.
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter3Parameter1 property
        ///
        /// \sa setFilter3Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter3Parameter1 ();
        /// Sets the value of the DepthNode::filter3Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter3Parameter1 property.
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter3Parameter1(), filter3Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter3Parameter1 (float value);
        /// Checks whether property DepthNode::filter3Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter3Parameter1 is read-only.
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter3Parameter1 is read-only
        ///
        /// \sa setFilter3Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter3Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 3
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter3Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter3Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter3Parameter2 property.
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter3Parameter2 property
        ///
        /// \sa setFilter3Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter3Parameter2 ();
        /// Sets the value of the DepthNode::filter3Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter3Parameter2 property.
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter3Parameter2(), filter3Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter3Parameter2 (float value);
        /// Checks whether property DepthNode::filter3Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter3Parameter2 is read-only.
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter3Parameter2 is read-only
        ///
        /// \sa setFilter3Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter3Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 3
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter3Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter3Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter3Parameter3 property.
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter3Parameter3 property
        ///
        /// \sa setFilter3Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter3Parameter3 ();
        /// Sets the value of the DepthNode::filter3Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter3Parameter3 property.
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter3Parameter3(), filter3Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter3Parameter3 (int32_t value);
        /// Checks whether property DepthNode::filter3Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter3Parameter3 is read-only.
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter3Parameter3 is read-only
        ///
        /// \sa setFilter3Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter3Parameter3IsReadOnly ();
        /// Specify the parameter 1 of filter 4
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter4Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter4Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter4Parameter1 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter4Parameter1 property
        ///
        /// \sa setFilter4Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter4Parameter1 ();
        /// Sets the value of the DepthNode::filter4Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter4Parameter1 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter4Parameter1(), filter4Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter4Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter4Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter4Parameter1 is read-only.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter4Parameter1 is read-only
        ///
        /// \sa setFilter4Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter4Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 5
        ///
        /// The DepthNode::filter5Parameter1 property specifies the
        /// parameter 1 of filter 5.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter5Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter5Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter5Parameter1 property.
        ///
        /// The DepthNode::filter5Parameter1 property specifies the
        /// parameter 1 of filter 5.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter5Parameter1 property
        ///
        /// \sa setFilter5Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter5Parameter1 ();
        /// Sets the value of the DepthNode::filter5Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter5Parameter1 property.
        ///
        /// The DepthNode::filter5Parameter1 property specifies the
        /// parameter 1 of filter 5.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter5Parameter1(), filter5Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter5Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter5Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter5Parameter1 is read-only.
        ///
        /// The DepthNode::filter5Parameter1 property specifies the
        /// parameter 1 of filter 5.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter5Parameter1 is read-only
        ///
        /// \sa setFilter5Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter5Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 6
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 1 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter6Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter6Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter6Parameter1 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 1 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter6Parameter1 property
        ///
        /// \sa setFilter6Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter6Parameter1 ();
        /// Sets the value of the DepthNode::filter6Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter6Parameter1 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 1 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter6Parameter1(), filter6Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter6Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter6Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter6Parameter1 is read-only.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 1 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter6Parameter1 is read-only
        ///
        /// \sa setFilter6Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter6Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 6
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 2 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter6Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter6Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter6Parameter2 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 2 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter6Parameter2 property
        ///
        /// \sa setFilter6Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter6Parameter2 ();
        /// Sets the value of the DepthNode::filter6Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter6Parameter2 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 2 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter6Parameter2(), filter6Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter6Parameter2 (int32_t value);
        /// Checks whether property DepthNode::filter6Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter6Parameter2 is read-only.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 2 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter6Parameter2 is read-only
        ///
        /// \sa setFilter6Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter6Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 6
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 3 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter6Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter6Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter6Parameter3 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 3 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter6Parameter3 property
        ///
        /// \sa setFilter6Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter6Parameter3 ();
        /// Sets the value of the DepthNode::filter6Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter6Parameter3 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 3 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter6Parameter3(), filter6Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter6Parameter3 (int32_t value);
        /// Checks whether property DepthNode::filter6Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter6Parameter3 is read-only.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 3 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter6Parameter3 is read-only
        ///
        /// \sa setFilter6Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter6Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 6
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 4 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter6Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter6Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter6Parameter4 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 4 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter6Parameter4 property
        ///
        /// \sa setFilter6Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter6Parameter4 ();
        /// Sets the value of the DepthNode::filter6Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter6Parameter4 property.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 4 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter6Parameter4(), filter6Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter6Parameter4 (int32_t value);
        /// Checks whether property DepthNode::filter6Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter6Parameter4 is read-only.
        ///
        /// The DepthNode::filter6Parameter1 property specifies the
        /// parameter 4 of filter 6.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter6Parameter4 is read-only
        ///
        /// \sa setFilter6Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter6Parameter4IsReadOnly ();
        /// Specify the parameter 1 of filter 8
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter8Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter8Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter8Parameter1 property.
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter8Parameter1 property
        ///
        /// \sa setFilter8Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter8Parameter1 ();
        /// Sets the value of the DepthNode::filter8Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter8Parameter1 property.
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter8Parameter1(), filter8Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter8Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter8Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter8Parameter1 is read-only.
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter8Parameter1 is read-only
        ///
        /// \sa setFilter8Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter8Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 9
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter9Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter1 property.
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter1 property
        ///
        /// \sa setFilter9Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter9Parameter1 ();
        /// Sets the value of the DepthNode::filter9Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter1 property.
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter1(), filter9Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter9Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter1 is read-only.
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter1 is read-only
        ///
        /// \sa setFilter9Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 9
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter9Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter2 property.
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter2 property
        ///
        /// \sa setFilter9Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter9Parameter2 ();
        /// Sets the value of the DepthNode::filter9Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter2 property.
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter2(), filter9Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter2 (float value);
        /// Checks whether property DepthNode::filter9Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter2 is read-only.
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter2 is read-only
        ///
        /// \sa setFilter9Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 9
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter9Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter3 property.
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter3 property
        ///
        /// \sa setFilter9Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter9Parameter3 ();
        /// Sets the value of the DepthNode::filter9Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter3 property.
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter3(), filter9Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter3 (float value);
        /// Checks whether property DepthNode::filter9Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter3 is read-only.
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter3 is read-only
        ///
        /// \sa setFilter9Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 9
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter9Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter4 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter4 property
        ///
        /// \sa setFilter9Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter9Parameter4 ();
        /// Sets the value of the DepthNode::filter9Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter4 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter4(), filter9Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter4 (float value);
        /// Checks whether property DepthNode::filter9Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter4 is read-only.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter4 is read-only
        ///
        /// \sa setFilter9Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter4IsReadOnly ();
        /// Whether to enable filter 7
        ///
        /// Specifies whether to enable filter 7
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter7;
        #endif
        /// Gets the value of the DepthNode::enableFilter7 property
        ///
        /// Gets the value of the DepthNode::enableFilter7 property.
        ///
        /// Specifies whether to enable filter 7
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter7 property
        ///
        /// \sa setEnableFilter7()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter7 ();
        /// Sets the value of the DepthNode::enableFilter7 property
        ///
        /// Sets the value of the DepthNode::enableFilter7 property.
        ///
        /// Specifies whether to enable filter 7
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter7(), enableFilter7IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter7 (bool value);
        /// Checks whether property DepthNode::enableFilter7 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter7 is read-only.
        ///
        /// Specifies whether to enable filter 7
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter7 is read-only
        ///
        /// \sa setEnableFilter7()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter7IsReadOnly ();
        /// Specify the parameter 1 of filter 7
        ///
        /// The DepthNode::filter7Parameter1 property specifies the
        /// parameter 1 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter7Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter7Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter7Parameter1 property.
        ///
        /// The DepthNode::filter7Parameter1 property specifies the
        /// parameter 1 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter7Parameter1 property
        ///
        /// \sa setFilter7Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter7Parameter1 ();
        /// Sets the value of the DepthNode::filter7Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter7Parameter1 property.
        ///
        /// The DepthNode::filter7Parameter1 property specifies the
        /// parameter 1 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter7Parameter1(), filter7Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter7Parameter1 (float value);
        /// Checks whether property DepthNode::filter7Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter7Parameter1 is read-only.
        ///
        /// The DepthNode::filter7Parameter1 property specifies the
        /// parameter 1 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter7Parameter1 is read-only
        ///
        /// \sa setFilter7Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter7Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 7
        ///
        /// The DepthNode::filter7Parameter2 property specifies the
        /// parameter 2 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter7Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter7Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter7Parameter2 property.
        ///
        /// The DepthNode::filter7Parameter2 property specifies the
        /// parameter 2 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter7Parameter2 property
        ///
        /// \sa setFilter7Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter7Parameter2 ();
        /// Sets the value of the DepthNode::filter7Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter7Parameter2 property.
        ///
        /// The DepthNode::filter7Parameter2 property specifies the
        /// parameter 2 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter7Parameter2(), filter7Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter7Parameter2 (float value);
        /// Checks whether property DepthNode::filter7Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter7Parameter2 is read-only.
        ///
        /// The DepthNode::filter7Parameter2 property specifies the
        /// parameter 2 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter7Parameter2 is read-only
        ///
        /// \sa setFilter7Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter7Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 7
        ///
        /// The DepthNode::filter7Parameter3 property specifies the
        /// parameter 3 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter7Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter7Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter7Parameter3 property.
        ///
        /// The DepthNode::filter7Parameter3 property specifies the
        /// parameter 3 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter7Parameter3 property
        ///
        /// \sa setFilter7Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter7Parameter3 ();
        /// Sets the value of the DepthNode::filter7Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter7Parameter3 property.
        ///
        /// The DepthNode::filter7Parameter3 property specifies the
        /// parameter 3 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter7Parameter3(), filter7Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter7Parameter3 (float value);
        /// Checks whether property DepthNode::filter7Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter7Parameter3 is read-only.
        ///
        /// The DepthNode::filter7Parameter3 property specifies the
        /// parameter 3 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter7Parameter3 is read-only
        ///
        /// \sa setFilter7Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter7Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 7
        ///
        /// The DepthNode::filter7Parameter4 property specifies the
        /// parameter 4 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter7Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter7Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter7Parameter4 property.
        ///
        /// The DepthNode::filter7Parameter4 property specifies the
        /// parameter 4 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter7Parameter4 property
        ///
        /// \sa setFilter7Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter7Parameter4 ();
        /// Sets the value of the DepthNode::filter7Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter7Parameter4 property.
        ///
        /// The DepthNode::filter7Parameter4 property specifies the
        /// parameter 4 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter7Parameter4(), filter7Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter7Parameter4 (float value);
        /// Checks whether property DepthNode::filter7Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter7Parameter4 is read-only.
        ///
        /// The DepthNode::filter7Parameter4 property specifies the
        /// parameter 4 of filter 7.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter7Parameter4 is read-only
        ///
        /// \sa setFilter7Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter7Parameter4IsReadOnly ();
        /// Whether to enable filter 10
        ///
        /// Specifies whether to enable filter 10
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter10;
        #endif
        /// Gets the value of the DepthNode::enableFilter10 property
        ///
        /// Gets the value of the DepthNode::enableFilter10 property.
        ///
        /// Specifies whether to enable filter 10
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter10 property
        ///
        /// \sa setEnableFilter10()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter10 ();
        /// Sets the value of the DepthNode::enableFilter10 property
        ///
        /// Sets the value of the DepthNode::enableFilter10 property.
        ///
        /// Specifies whether to enable filter 10
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter10(), enableFilter10IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter10 (bool value);
        /// Checks whether property DepthNode::enableFilter10 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter10 is read-only.
        ///
        /// Specifies whether to enable filter 10
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter10 is read-only
        ///
        /// \sa setEnableFilter10()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter10IsReadOnly ();
        /// Specify the parameter 1 of filter 10
        ///
        /// The DepthNode::filter10Parameter1 property specifies the
        /// parameter 1 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter10Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter10Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter10Parameter1 property.
        ///
        /// The DepthNode::filter10Parameter1 property specifies the
        /// parameter 1 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter10Parameter1 property
        ///
        /// \sa setFilter10Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter10Parameter1 ();
        /// Sets the value of the DepthNode::filter10Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter10Parameter1 property.
        ///
        /// The DepthNode::filter10Parameter1 property specifies the
        /// parameter 1 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter10Parameter1(), filter10Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter10Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter10Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter10Parameter1 is read-only.
        ///
        /// The DepthNode::filter10Parameter1 property specifies the
        /// parameter 1 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter10Parameter1 is read-only
        ///
        /// \sa setFilter10Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter10Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 10
        ///
        /// The DepthNode::filter10Parameter2 property specifies the
        /// parameter 2 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter10Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter10Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter10Parameter2 property.
        ///
        /// The DepthNode::filter10Parameter2 property specifies the
        /// parameter 2 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter10Parameter2 property
        ///
        /// \sa setFilter10Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter10Parameter2 ();
        /// Sets the value of the DepthNode::filter10Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter10Parameter2 property.
        ///
        /// The DepthNode::filter10Parameter2 property specifies the
        /// parameter 2 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter10Parameter2(), filter10Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter10Parameter2 (int32_t value);
        /// Checks whether property DepthNode::filter10Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter10Parameter2 is read-only.
        ///
        /// The DepthNode::filter10Parameter2 property specifies the
        /// parameter 2 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter10Parameter2 is read-only
        ///
        /// \sa setFilter10Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter10Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 10
        ///
        /// The DepthNode::filter10Parameter3 property specifies the
        /// parameter 3 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter10Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter10Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter10Parameter3 property.
        ///
        /// The DepthNode::filter10Parameter3 property specifies the
        /// parameter 3 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter10Parameter3 property
        ///
        /// \sa setFilter10Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter10Parameter3 ();
        /// Sets the value of the DepthNode::filter10Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter10Parameter3 property.
        ///
        /// The DepthNode::filter10Parameter3 property specifies the
        /// parameter 3 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter10Parameter3(), filter10Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter10Parameter3 (int32_t value);
        /// Checks whether property DepthNode::filter10Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter10Parameter3 is read-only.
        ///
        /// The DepthNode::filter10Parameter3 property specifies the
        /// parameter 3 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter10Parameter3 is read-only
        ///
        /// \sa setFilter10Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter10Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 10
        ///
        /// The DepthNode::filter10Parameter4 property specifies the
        /// parameter 4 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter10Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter10Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter10Parameter4 property.
        ///
        /// The DepthNode::filter10Parameter4 property specifies the
        /// parameter 4 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter10Parameter4 property
        ///
        /// \sa setFilter10Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter10Parameter4 ();
        /// Sets the value of the DepthNode::filter10Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter10Parameter4 property.
        ///
        /// The DepthNode::filter10Parameter4 property specifies the
        /// parameter 4 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter10Parameter4(), filter10Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter10Parameter4 (int32_t value);
        /// Checks whether property DepthNode::filter10Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter10Parameter4 is read-only.
        ///
        /// The DepthNode::filter10Parameter4 property specifies the
        /// parameter 4 of filter 10.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter10Parameter4 is read-only
        ///
        /// \sa setFilter10Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter10Parameter4IsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::DepthNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// the confidence map
            ::DepthSense::Pointer< int16_t > confidenceMap;
            /// The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            ::DepthSense::Pointer< int16_t > phaseMap;
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            ::DepthSense::Pointer< int16_t > depthMap;
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            ::DepthSense::Pointer< float > depthMapFloatingPoint;
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
            ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
            ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            ::DepthSense::Pointer< DepthSense::UV > uvMap;
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
            DepthSense::DepthNode::Acceleration acceleration;
            /// the system model parameters that were in effect at the time of capture. The coordinate system used 
            DepthSense::StereoCameraParameters stereoCameraParameters;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::DepthNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceived event is raised when a depth sample
        /// is captured.
        ///
        /// \param confidenceMap the confidence map
        /// \param phaseMap The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
        /// \param depthMap The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
        /// \param depthMapFloatingPoint The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
        /// \param vertices The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param verticesFloatingPoint The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param uvMap The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
        /// \param acceleration The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param stereoCameraParameters the system model parameters that were in effect at the time of capture. The coordinate system used 
        /// for the extrinsics is the one specified through \c coordinateSystemType property.
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        /// \struct NewSampleReceived2Data DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceived2Event arguments
        ///
        /// The NewSampleReceived2Data struct holds the DepthSense::DepthNode::NewSampleReceived2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceived2Data
        {
            DepthSense::Depth::SampleData data;
        };
        /// \class NewSampleReceived2Event DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceived2 event is raised when a depth sample
        /// is captured.
        class NewSampleReceived2Event : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>
        {
            private:
            NewSampleReceived2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceived2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived2 event object
        ///
        /// Returns a reference to the \c newSampleReceived2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceived2Event& newSampleReceived2Event () const;
        /// \struct NewSampleReceivedEx2Data DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceivedEx2Event arguments
        ///
        /// The NewSampleReceivedEx2Data struct holds the DepthSense::DepthNode::NewSampleReceivedEx2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedEx2Data
        {
            DepthSense::Depth::SampleDataEx data;
        };
        /// \class NewSampleReceivedEx2Event DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceivedEx2 event is raised when a depth sample
        /// is captured.
        class NewSampleReceivedEx2Event : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>
        {
            private:
            NewSampleReceivedEx2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedEx2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedEx2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedEx2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedEx2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedEx2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedEx2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedEx2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedEx2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedEx2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedEx2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::SampleDataEx data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedEx2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceivedEx2 event object
        ///
        /// Returns a reference to the \c newSampleReceivedEx2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceivedEx2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceivedEx2Event& newSampleReceivedEx2Event () const;
        #ifndef DEPTHSENSE_DOC
        struct NewSampleReceivedExData_p
        {
            ::DepthSense::Pointer< int16_t > rawData;
            ::DepthSense::Pointer< int16_t > confidenceMap;
            ::DepthSense::Pointer< int16_t > phaseMap;
            ::DepthSense::Pointer< int16_t > depthMap;
            ::DepthSense::Pointer< float > depthMapFloatingPoint;
            ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            ::DepthSense::Pointer< DepthSense::UV > uvMap;
            DepthSense::DepthNode::Configuration captureConfiguration;
            DepthSense::DepthNode::Acceleration acceleration;
            ::DSI::Vector< DepthSense::SensorValue > sensorValues;
            DepthSense::StereoCameraParameters stereoCameraParameters;
            uint64_t timeOfCapture;
            uint64_t timeOfArrival;
            int32_t droppedSampleCount;
            int32_t cumulativeDroppedSampleCount;
            ::DepthSense::Pointer< uint16_t > ambientMap;
        };
        #endif
        /// \struct NewSampleReceivedExData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceivedExEvent arguments
        ///
        /// The NewSampleReceivedExData struct holds the DepthSense::DepthNode::NewSampleReceivedExEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedExData
        {
            /// the raw data as received from the device.
            ::DepthSense::Pointer< int16_t > rawData;
            /// the confidence map
            ::DepthSense::Pointer< int16_t > confidenceMap;
            /// The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            ::DepthSense::Pointer< int16_t > phaseMap;
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            ::DepthSense::Pointer< int16_t > depthMap;
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            ::DepthSense::Pointer< float > depthMapFloatingPoint;
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
            ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
            ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            ::DepthSense::Pointer< DepthSense::UV > uvMap;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::DepthNode::Configuration captureConfiguration;
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used
            DepthSense::DepthNode::Acceleration acceleration;
            /// the temperature reported by the sensors when the frame was captured.
            std::vector< DepthSense::SensorValue > sensorValues;
            /// the system model parameters that were in effect at the time of capture. The coordinate system used 
            DepthSense::StereoCameraParameters stereoCameraParameters;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
            /// the ambient map
            ::DepthSense::Pointer< uint16_t > ambientMap;
        };
        /// \class NewSampleReceivedExEvent DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceivedEx event is raised when a depth sample
        /// is captured.
        ///
        /// \param confidenceMap the confidence map
        /// \param phaseMap The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
        /// \param depthMap The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
        /// \param depthMapFloatingPoint The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
        /// \param vertices The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param verticesFloatingPoint The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param uvMap The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
        /// \param acceleration The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used
        /// is the one specified through \c coordinateSystemType property.
        /// \param stereoCameraParameters the system model parameters that were in effect at the time of capture. The coordinate system used 
        /// for the extrinsics is the one specified through \c coordinateSystemType property.
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        /// \param rawData the raw data as received from the device.
        /// \param ambientMap the ambient map
        /// \param sensorValues the temperature reported by the sensors when the frame was captured.
        class NewSampleReceivedExEvent : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>
        {
            private:
            NewSampleReceivedExEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::DepthNode, NewSampleReceivedExData_p>
            {
                public:
                typedef void (*Function) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData_p data)
                {
                    NewSampleReceivedExData publicData;
                    publicData.rawData = data.rawData;
                    publicData.confidenceMap = data.confidenceMap;
                    publicData.phaseMap = data.phaseMap;
                    publicData.depthMap = data.depthMap;
                    publicData.depthMapFloatingPoint = data.depthMapFloatingPoint;
                    publicData.vertices = data.vertices;
                    publicData.verticesFloatingPoint = data.verticesFloatingPoint;
                    publicData.uvMap = data.uvMap;
                    publicData.captureConfiguration = data.captureConfiguration;
                    publicData.acceleration = data.acceleration;
                    publicData.sensorValues = data.sensorValues.unmarshal();
                    publicData.stereoCameraParameters = data.stereoCameraParameters;
                    publicData.timeOfCapture = data.timeOfCapture;
                    publicData.timeOfArrival = data.timeOfArrival;
                    publicData.droppedSampleCount = data.droppedSampleCount;
                    publicData.cumulativeDroppedSampleCount = data.cumulativeDroppedSampleCount;
                    publicData.ambientMap = data.ambientMap;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedExData_p data)
                {
                    _func(obj, data.rawData, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.captureConfiguration, data.acceleration, data.sensorValues.unmarshal(), data.stereoCameraParameters, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, data.ambientMap);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::DepthNode, NewSampleReceivedExData_p>
            {
                public:
                typedef void (*Function) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData_p data)
                {
                    NewSampleReceivedExData publicData;
                    publicData.rawData = data.rawData;
                    publicData.confidenceMap = data.confidenceMap;
                    publicData.phaseMap = data.phaseMap;
                    publicData.depthMap = data.depthMap;
                    publicData.depthMapFloatingPoint = data.depthMapFloatingPoint;
                    publicData.vertices = data.vertices;
                    publicData.verticesFloatingPoint = data.verticesFloatingPoint;
                    publicData.uvMap = data.uvMap;
                    publicData.captureConfiguration = data.captureConfiguration;
                    publicData.acceleration = data.acceleration;
                    publicData.sensorValues = data.sensorValues.unmarshal();
                    publicData.stereoCameraParameters = data.stereoCameraParameters;
                    publicData.timeOfCapture = data.timeOfCapture;
                    publicData.timeOfArrival = data.timeOfArrival;
                    publicData.droppedSampleCount = data.droppedSampleCount;
                    publicData.cumulativeDroppedSampleCount = data.cumulativeDroppedSampleCount;
                    publicData.ambientMap = data.ambientMap;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedExData_p data)
                {
                    _func(obj, data.rawData, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.captureConfiguration, data.acceleration, data.sensorValues.unmarshal(), data.stereoCameraParameters, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, data.ambientMap, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::DepthNode, NewSampleReceivedExData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData_p data)
                {
                    NewSampleReceivedExData publicData;
                    publicData.rawData = data.rawData;
                    publicData.confidenceMap = data.confidenceMap;
                    publicData.phaseMap = data.phaseMap;
                    publicData.depthMap = data.depthMap;
                    publicData.depthMapFloatingPoint = data.depthMapFloatingPoint;
                    publicData.vertices = data.vertices;
                    publicData.verticesFloatingPoint = data.verticesFloatingPoint;
                    publicData.uvMap = data.uvMap;
                    publicData.captureConfiguration = data.captureConfiguration;
                    publicData.acceleration = data.acceleration;
                    publicData.sensorValues = data.sensorValues.unmarshal();
                    publicData.stereoCameraParameters = data.stereoCameraParameters;
                    publicData.timeOfCapture = data.timeOfCapture;
                    publicData.timeOfArrival = data.timeOfArrival;
                    publicData.droppedSampleCount = data.droppedSampleCount;
                    publicData.cumulativeDroppedSampleCount = data.cumulativeDroppedSampleCount;
                    publicData.ambientMap = data.ambientMap;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedExData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedExData_p, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap)>::_method))(obj, data.rawData, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.captureConfiguration, data.acceleration, data.sensorValues.unmarshal(), data.stereoCameraParameters, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, data.ambientMap);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p rawData</td><td>the raw data as received from the device.</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used</td></tr>
            ///   <tr><td>\p sensorValues</td><td>the temperature reported by the sensors when the frame was captured.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p ambientMap</td><td>the ambient map</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p rawData</td><td>the raw data as received from the device.</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used</td></tr>
            ///   <tr><td>\p sensorValues</td><td>the temperature reported by the sensors when the frame was captured.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p ambientMap</td><td>the ambient map</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p rawData</td><td>the raw data as received from the device.</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used</td></tr>
            ///   <tr><td>\p sensorValues</td><td>the temperature reported by the sensors when the frame was captured.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p ambientMap</td><td>the ambient map</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p rawData</td><td>the raw data as received from the device.</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used</td></tr>
            ///   <tr><td>\p sensorValues</td><td>the temperature reported by the sensors when the frame was captured.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p ambientMap</td><td>the ambient map</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedExData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p rawData</td><td>the raw data as received from the device.</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used</td></tr>
            ///   <tr><td>\p sensorValues</td><td>the temperature reported by the sensors when the frame was captured.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p ambientMap</td><td>the ambient map</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p rawData</td><td>the raw data as received from the device.</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used</td></tr>
            ///   <tr><td>\p sensorValues</td><td>the temperature reported by the sensors when the frame was captured.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p ambientMap</td><td>the ambient map</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > rawData, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Configuration captureConfiguration, DepthSense::DepthNode::Acceleration acceleration, std::vector< DepthSense::SensorValue > sensorValues, DepthSense::StereoCameraParameters stereoCameraParameters, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ::DepthSense::Pointer< uint16_t > ambientMap))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedExData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceivedEx event object
        ///
        /// Returns a reference to the \c newSampleReceivedEx event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceivedEx event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceivedExEvent& newSampleReceivedExEvent () const;
        /// \struct ButtonPressedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::ButtonPressedEvent arguments
        ///
        /// The ButtonPressedData struct holds the DepthSense::DepthNode::ButtonPressedEvent parameters and is passed to callbacks connected to that event.
        struct ButtonPressedData
        {
            DepthSense::Depth::ButtonEventData buttonEventData;
        };
        /// \class ButtonPressedEvent DepthSense.hxx
        /// Event raised when a button is pressed.
        ///
        /// The \c buttonPressed event is raised when a button is pressed on the camera.
        ///
        /// \param buttoneventData data assciated with the button event - the button ID
        ///
        class ButtonPressedEvent : public DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>
        {
            private:
            ButtonPressedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonPressedData data)
                {
                    _func(obj, data.buttonEventData);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonPressedData data)
                {
                    _func(obj, data.buttonEventData, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonPressedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_method))(obj, data.buttonEventData);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonPressedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonPressedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonPressedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonPressedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonPressedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonPressedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c buttonPressed event object
        ///
        /// Returns a reference to the \c buttonPressed event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c buttonPressed event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::ButtonPressedEvent& buttonPressedEvent () const;
        /// \struct ButtonReleasedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::ButtonReleasedEvent arguments
        ///
        /// The ButtonReleasedData struct holds the DepthSense::DepthNode::ButtonReleasedEvent parameters and is passed to callbacks connected to that event.
        struct ButtonReleasedData
        {
            DepthSense::Depth::ButtonEventData buttonEventData;
        };
        /// \class ButtonReleasedEvent DepthSense.hxx
        /// Event raised when a button is release.
        ///
        /// The \c buttonPressed event is raised when a button is released on the camera.
        ///
        /// \param buttoneventData data assciated with the button event - the button ID
        ///
        class ButtonReleasedEvent : public DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>
        {
            private:
            ButtonReleasedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonReleasedData data)
                {
                    _func(obj, data.buttonEventData);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonReleasedData data)
                {
                    _func(obj, data.buttonEventData, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonReleasedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_method))(obj, data.buttonEventData);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonReleasedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonReleasedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonReleasedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonReleasedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonReleasedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonReleasedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c buttonReleased event object
        ///
        /// Returns a reference to the \c buttonReleased event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c buttonReleased event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::ButtonReleasedEvent& buttonReleasedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class UnsupportedNode DepthSense.hxx
    /// Represents an unsupported stream data source
    ///   
    /// The UnsupportedNode class allows to have some information about 
    /// an unsupported device. This node can not be registered neither controlled.
    class UnsupportedNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API UnsupportedNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API UnsupportedNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API UnsupportedNode (const UnsupportedNode& other);
        DEPTHSENSE_API UnsupportedNode& operator= (const UnsupportedNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~UnsupportedNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit UnsupportedNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit UnsupportedNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::UnsupportedNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::UnsupportedNode type object
        ///
        /// Returns the DepthSense::UnsupportedNode type object
        ///
        /// \return the DepthSense::UnsupportedNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The reason the node is unsupported
        ///   
        /// The UnsupportedNode::reason property specifies the reason
        /// why the node is not supported.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string reason;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getReason ();
        public:
        /// Gets the value of the UnsupportedNode::reason property
        ///
        /// Gets the value of the UnsupportedNode::reason property.
        ///
        ///
        /// \return the value of the UnsupportedNode::reason property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getReason ()
        {
            std::string retval = _p_getReason().unmarshal();
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Device DepthSense.hxx
    /// Represents a camera device
    ///   
    /// The Device class represents a physical camera device connected
    /// to the host. It exposes device information (serial number,
    /// model and so on) and contains a number of stream data sources
    /// designated as \em nodes.
    class Device
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Device (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Device ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Device (const Device& other);
        DEPTHSENSE_API Device& operator= (const Device& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Device ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Device (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Device& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Device type object
        ///
        /// Returns the DepthSense::Device type object
        ///
        /// \return the DepthSense::Device type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The camera model
        ///
        /// An enumeration comprising all the camera models supported by
        /// DepthSense SDK.
        enum Model
        {
            MODEL_UNKNOWN = 0,/*!< unknown model */
            MODEL_DS320 = 1,/*!< DepthSense 320 */
            MODEL_DS325 = 2,/*!< DepthSense 325 */
            MODEL_DS311 = 3,/*!< DepthSense 311 */
            MODEL_GENERIC = 4,/*!< Generic */
            MODEL_VF0780 = 5,/*!< DepthSense 325 */
            MODEL_MOCK = 6,/*!< Mock device */
            MODEL_TICDK = 7,/*!< TI-CDK */
            MODEL_DS536 = 8,/*!< DS536 */
            MODEL_SKCDK = 9,/*!< SK-CDK */
            MODEL_DS326 = 10,/*!< DepthSense 326 */
            MODEL_IMP_DS327 = 11,/*!< Imprivata DS327 */
            MODEL_DS536A = 12,/*!< DS536A */
            MODEL_DS536B = 13,/*!< DS536B */
            MODEL_DS325B = 14,/*!< DS325B */
            MODEL_STEREOLR = 129,/*!< StereoLR */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String Model_toString_p (Model value);
        #endif
        /// Converts a DepthSense::Device::Model value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Device::Model, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string Model_toString (Model value)
        {
            return Model_toString_p(value).unmarshal();
        }
        /// A bitmask of capabilities supported by the camera
        ///   
        /// A bitmask of capabilities supported by the camera.
        enum Capabilities
        {
            CAPABILITIES_COLOR = 1,/*!< the camera supports color streaming */
            CAPABILITIES_DEPTH = 2,/*!< the camera supports depth streaming */
            CAPABILITIES_AUDIO = 4,/*!< the camera supports audio streaming */
            CAPABILITIES_ACCELEROMETER = 8,/*!< the camera has an accelerometer */
            CAPABILITIES_IMU = 16,/*!< The camera has an IMU */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String Capabilities_toString_p (Capabilities value);
        #endif
        /// Converts a DepthSense::Device::Capabilities value to a string
        ///
        /// Converts the provided bitmask to a string.
        ///
        /// \param value the bitmask to convert
        ///
        /// \return a string of the form <tt>"Flag1 | Flag2 | Flag3"</tt>; unknown bits are omitted from the representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string Capabilities_toString (Capabilities value)
        {
            return Capabilities_toString_p(value).unmarshal();
        }
        /// The camera serial number
        ///   
        /// The Device::serialNumber property specifies the serial
        /// number of the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Device::serialNumber property
        ///
        /// Gets the value of the Device::serialNumber property.
        ///
        ///
        /// \return the value of the Device::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        /// The camera model
        ///   
        /// The Device::model property specifies the model of the
        /// current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::Device::Model model;
        #endif
        /// Gets the value of the Device::model property
        ///
        /// Gets the value of the Device::model property.
        ///
        ///
        /// \return the value of the Device::model property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::Model getModel ();
        /// The TOF controller firmware version
        ///
        /// The Device::tofControllerVersion property specifies the
        /// TOF controller firmware version of the current device.
        /// This property is initialized after the node has streamed
        /// for the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t tofControllerVersion;
        #endif
        /// Gets the value of the Device::tofControllerVersion property
        ///
        /// Gets the value of the Device::tofControllerVersion property.
        ///
        /// The Device::tofControllerVersion property specifies the
        /// TOF controller firmware version of the current device.
        /// This property is initialized after the node has streamed
        /// for the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::tofControllerVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getTofControllerVersion ();
        /// The USB backend firmware version
        ///
        /// The Device::usbBackendVersion property specifies the USB
        /// backend firmware version of the current device. This
        /// property is initialized after the node has streamed for
        /// the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t usbBackendVersion;
        #endif
        /// Gets the value of the Device::usbBackendVersion property
        ///
        /// Gets the value of the Device::usbBackendVersion property.
        ///
        /// The Device::usbBackendVersion property specifies the USB
        /// backend firmware version of the current device. This
        /// property is initialized after the node has streamed for
        /// the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::usbBackendVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getUsbBackendVersion ();
        /// The camera overheating status
        ///
        /// The DepthNode::overheating property is true if at least one soft threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool overheating;
        #endif
        /// Gets the value of the Device::overheating property
        ///
        /// Gets the value of the Device::overheating property.
        ///
        /// The DepthNode::overheating property is true if at least one soft threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the Device::overheating property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getOverheating ();
        /// The camera overheated status
        ///
        /// The DepthNode::overheated property is true if at least one hard threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool overheated;
        #endif
        /// Gets the value of the Device::overheated property
        ///
        /// Gets the value of the Device::overheated property.
        ///
        /// The DepthNode::overheated property is true if at least one hard threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the Device::overheated property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getOverheated ();
        /// The camera capabilities
        ///   
        /// The Device::capabilities property specifies the
        /// capabilities of the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::Device::Capabilities capabilities;
        #endif
        /// Gets the value of the Device::capabilities property
        ///
        /// Gets the value of the Device::capabilities property.
        ///
        ///
        /// \return the value of the Device::capabilities property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::Capabilities getCapabilities ();
        /// The stream data sources
        ///   
        /// The Device::nodes property specifies the stream data
        /// sources exposed by the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Node > nodes;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Node > _p_getNodes ();
        public:
        /// Gets the value of the Device::nodes property
        ///
        /// Gets the value of the Device::nodes property.
        ///
        ///
        /// \return the value of the Device::nodes property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Node > getNodes ()
        {
            std::vector< DepthSense::Node > retval = _p_getNodes().unmarshal();
            return retval;
        }
        /// The system model parameters
        ///
        /// The DepthSense::StereoCameraParameters property specifies the system 
        /// model parameters. The coordinate system used 
        /// for the extrinsics is the one specified through \c DepthNode::coordinateSystemType property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::StereoCameraParameters stereoCameraParameters;
        #endif
        /// Gets the value of the Device::stereoCameraParameters property
        ///
        /// Gets the value of the Device::stereoCameraParameters property.
        ///
        /// The DepthSense::StereoCameraParameters property specifies the system 
        /// model parameters. The coordinate system used 
        /// for the extrinsics is the one specified through \c DepthNode::coordinateSystemType property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::stereoCameraParameters property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::StereoCameraParameters getStereoCameraParameters ();
        /// \struct NodeAddedData DepthSense.hxx
        /// Holds the DepthSense::Device::NodeAddedEvent arguments
        ///
        /// The NodeAddedData struct holds the DepthSense::Device::NodeAddedEvent parameters and is passed to callbacks connected to that event.
        struct NodeAddedData
        {
            /// the node that was attached to the current device
            DepthSense::Node node;
        };
        /// \class NodeAddedEvent DepthSense.hxx
        /// Event raised when a node is attached to the current device
        ///   
        /// The \c nodeAdded event is raised when a stream data source
        /// is attached to the current device.
        ///
        /// \param node the node that was attached to the current device
        ///
        /// \sa NodeRemovedEvent
        class NodeAddedEvent : public DepthSense::Event<DepthSense::Device, NodeAddedData>
        {
            private:
            NodeAddedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Device, NodeAddedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>(func)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    _func(obj, data.node);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    _func(obj, data.node, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_method))(obj, data.node);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::FunctionHandler<DepthSense::Device, NodeAddedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Device, NodeAddedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::ClosureHandler<DepthSense::Device, NodeAddedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Device, NodeAddedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::MethodHandler<DepthSense::Device, NodeAddedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Device, NodeAddedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c nodeAdded event object
        ///
        /// Returns a reference to the \c nodeAdded event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c nodeAdded event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::NodeAddedEvent& nodeAddedEvent () const;
        /// \struct NodeRemovedData DepthSense.hxx
        /// Holds the DepthSense::Device::NodeRemovedEvent arguments
        ///
        /// The NodeRemovedData struct holds the DepthSense::Device::NodeRemovedEvent parameters and is passed to callbacks connected to that event.
        struct NodeRemovedData
        {
            /// the node that was detached from the current device
            DepthSense::Node node;
        };
        /// \class NodeRemovedEvent DepthSense.hxx
        /// Event raised when a node is detached from the current device
        ///   
        /// The \c nodeRemoved event is raised when a stream data source
        /// is detached from the current device.
        ///
        /// \param node the node that was detached from the current device
        ///
        /// \sa NodeAddedEvent
        class NodeRemovedEvent : public DepthSense::Event<DepthSense::Device, NodeRemovedData>
        {
            private:
            NodeRemovedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Device, NodeRemovedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>(func)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    _func(obj, data.node);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    _func(obj, data.node, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_method))(obj, data.node);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::FunctionHandler<DepthSense::Device, NodeRemovedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Device, NodeRemovedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::ClosureHandler<DepthSense::Device, NodeRemovedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Device, NodeRemovedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::MethodHandler<DepthSense::Device, NodeRemovedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Device, NodeRemovedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c nodeRemoved event object
        ///
        /// Returns a reference to the \c nodeRemoved event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c nodeRemoved event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::NodeRemovedEvent& nodeRemovedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Context DepthSense.hxx
    /// Represents an application session
    ///   
    /// The Context class represents an application session (either a
    /// standalone session or a TCP/IP client connection). A context
    /// can group a number of nodes from different devices for simultaneous
    /// monitoring of several stream data sources.
    ///
    /// Object instances obtained from a given Context instance (such
    /// as the list of devices connected to the host, or the list of
    /// nodes belonging to a specific device) are implicitly attached
    /// to that Context instance, which is then termed the object's
    /// <em>parent context</em>. Any operation performed on a device
    /// or node automatically makes use of its parent context.
    class Context
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Context (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::BaseValue;
        friend class DepthSense::GPIOValue;
        friend class DepthSense::FloatParameterValue;
        friend class DepthSense::BoolParameterValue;
        friend class DepthSense::IntParameterValue;
        friend class DepthSense::RegionOfInterestValue;
        friend class DepthSense::I2CArrayValue;
        friend class DepthSense::RegisterValue;
        friend class DepthSense::SystemInfoValue;
        friend class DepthSense::SystemCalibrationValue;
        friend class DepthSense::TemperatureCorrection;
        friend class DepthSense::CyclicErrorCorrection;
        friend class DepthSense::GradientDistortionCorrection;
        friend class DepthSense::Calibration;
        friend class DepthSense::HardwareVersion;
        friend class DepthSense::SystemStateValue;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::Depth::SampleDataEx;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Context ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Context (const Context& other);
        DEPTHSENSE_API Context& operator= (const Context& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Context ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Context (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Context& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Context type object
        ///
        /// Returns the DepthSense::Context type object
        ///
        /// \return the DepthSense::Context type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \c localhost, port \c 6809.
        ///
        /// \return the resulting context
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(const char*), create(const char*, int32_t), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create ();
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \p hostname, port \c 6809.
        ///
        /// \param hostname the host or IP address to connect to
        ///
        /// \return the resulting context
        ///
        /// \warning the \p hostname parameter is currently ignored,
        /// \c localhost is always used
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*, int32_t), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create (const char* hostname);
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \p hostname, port \c port.
        ///
        /// \param hostname the host or IP address to connect to
        /// \param port the port to connect to
        ///
        /// \return the resulting context
        ///
        /// \warning the \p hostname parameter is currently ignored,
        /// \c localhost is always used
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create (const char* hostname, int32_t port);
        /// Creates a standalone DepthSense context
        ///
        /// Creates a standalone DepthSense context.
        ///
        /// \return the resulting context
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*), create(const char*, int32_t)
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context createStandalone ();
        /// Runs the DepthSense event loop
        ///
        /// Runs the DepthSense event loop. The connected event
        /// handlers are run in the thread that called run().
        ///
        /// If the server throws an exception asynchronously (that is,
        /// not in reaction to a method call or property
        /// assignment/retrieval), it will be propagated to this
        /// method.
        ///
        /// To exit the event loop, call quit().
        ///
        /// \sa quit()
        ///
        /// \exception DepthSense::InvalidOperationException the DepthSense event loop is already running in the current application
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::StreamingException a streaming error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::IOException a device I/O operation has failed
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void run ();
        /// Terminates the DepthSense event loop
        ///
        /// Terminates the DepthSense event loop.
        ///
        /// \sa run()
        ///
        /// \exception DepthSense::InvalidOperationException the DepthSense event loop is not running in the current application
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void quit ();
        /// Starts monitoring a node
        ///   
        /// Registers a node with the current context. All registered
        /// nodes will be used as actual stream data sources.
        /// If the streaming is already started, the registered node
        /// will automatically start streaming.
        ///
        /// \param node the node to be registered
        ///
        /// \sa unregisterNode(), getRegisteredNodes()
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, already registered or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::StreamingException a streaming error has occured
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void registerNode (DepthSense::Node node);
        /// Stops monitoring a node
        ///    
        /// Removes the specified node from the list of monitored nodes of the
        /// current context.
        ///
        /// \param node the node to be unregistered
        ///
        /// \pre
        /// The provided node must have been subject to a prior call
        /// to registerNode().
        ///
        /// \sa registerNode(), getRegisteredNodes()
        ///
        /// \exception DepthSense::ArgumentException \p node is unset or not registered
        /// \exception DepthSense::StreamingException a streaming error has occured
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void unregisterNode (DepthSense::Node node);
        /// Starts the capture on the registered nodes
        ///    
        /// Starts the capture (streaming) on the nodes registered with the
        /// current context.
        ///
        /// \sa stopNodes()
        ///
        /// \exception DepthSense::ConfigurationException a valid node configuration failed to apply
        /// \exception DepthSense::StreamingException streaming could not be started
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void startNodes ();
        /// Stops the capture on the registered nodes
        ///    
        /// Stops the capture (streaming) on the nodes registered with the
        /// current context.
        ///
        /// \sa startNodes()
        ///
        /// \exception DepthSense::StreamingException streaming could not be stopped
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void stopNodes ();
        /// Requests control of a device
        ///   
        /// Requests full control access on \p device and its nodes. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a device or any of its exposed properties.
        ///
        /// This methods blocks indefinitely until control is granted
        /// to the caller or the device is detached from the host system.
        ///
        /// \param device the device to request control of
        ///
        /// \sa requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context already controls it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Device device);
        /// Requests control of a device
        ///   
        /// Requests full control access on \p device and its nodes. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a device or any of its exposed properties.
        /// This method will try to request the control of all the nodes of the DepthSense::Device.
        /// In case of failure, none of the nodes will be controlled. When a context has the control
        /// over a DepthSense::Device, the context will be granted control on any new node added to 
        /// the DepthSense::Device.
        ///
        /// \param device the device to request control of
        /// \param timeout the timeout in milliseconds
        ///
        /// \sa requestControl(Device), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context already controls it
        /// \exception DepthSense::TimeoutException \p timeout has expired before control could be obtained
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Device device, int32_t timeout);
        /// Releases control of a device
        ///
        /// Releases full control access on \p device. If other clients/contexts
        /// are waiting for full control access on the same device or one of
        /// its nodes, control will be transferred to one of them, chosen
        /// randomly.
        ///
        /// \param device the device to release control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context does not control it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void releaseControl (DepthSense::Device device);
        /// Requests control of a node
        ///   
        /// Requests full control access on \p node. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device node. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a node or any of its exposed
        /// properties.
        ///
        /// This methods blocks indefinitely until control is granted
        /// to the caller or the node is detached from the host system.
        ///
        /// \param node the node to request control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, the current context already controls it, or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Node node);
        /// Requests control of a node
        ///   
        /// Requests full control access on \p node. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device node. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a node or any of its exposed
        /// properties.
        ///
        /// \param node the node to request control of
        /// \param timeout the timeout in milliseconds
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, the current context already controls it, or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::TimeoutException \p timeout has expired before control could be obtained
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Node node, int32_t timeout);
        /// Releases control of a node
        ///
        /// Releases full control access on \p node. If other
        /// clients/contexts are waiting for full control access on
        /// the same node control will be transferred to one of them,
        /// chosen randomly.
        ///
        /// \param node the node to release control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, or the current context does not control it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void releaseControl (DepthSense::Node node);
        /// Client-side version information
        ///
        /// The Context::getClientVersion method returns the client-side version information.
        ///
        /// \return the client-side version information
        ///
        /// \sa Context::getServerVersion
        /// \sa getLibraryVersion
        ///
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or is a standalone context  
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Version getClientVersion ();
        /// Server-side version information
        ///
        /// The Context::getServerVersion method returns the server-side version information.
        ///
        /// \return the server-side version information
        ///
        /// \sa Context::getClientVersion
        /// \sa getLibraryVersion
        ///
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or is a standalone context  
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Version getServerVersion ();
        /// The list of registered nodes
        ///
        /// The Context::registeredNodes property contains the list of
        /// nodes registered with registerNode().
        ///
        /// \sa registerNode(), unregisterNode()
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Node > registeredNodes;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Node > _p_getRegisteredNodes ();
        public:
        /// Gets the value of the Context::registeredNodes property
        ///
        /// Gets the value of the Context::registeredNodes property.
        ///
        /// The Context::registeredNodes property contains the list of
        /// nodes registered with registerNode().
        ///
        /// \sa registerNode(), unregisterNode()
        ///
        /// \return the value of the Context::registeredNodes property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Node > getRegisteredNodes ()
        {
            std::vector< DepthSense::Node > retval = _p_getRegisteredNodes().unmarshal();
            return retval;
        }
        /// The list of connected devices
        ///
        /// The Context::devices property contains the list of camera devices
        /// attached to the host.
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Device > devices;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Device > _p_getDevices ();
        public:
        /// Gets the value of the Context::devices property
        ///
        /// Gets the value of the Context::devices property.
        ///
        /// The Context::devices property contains the list of camera devices
        /// attached to the host.
        ///
        /// \return the value of the Context::devices property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Device > getDevices ()
        {
            std::vector< DepthSense::Device > retval = _p_getDevices().unmarshal();
            return retval;
        }
        /// Whether to disable auto-configuration for all the depth nodes
        ///
        /// Specifies whether to disable the auto-configuration of all the
        /// depth nodes. Note that this call must be issued before any device is enumerated.
        /// Setting this property to true can prevent DepthSenseSDK to safely retrieve some information
        /// from the device (typically the controller FW version).
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or at least one device has already been enumerated.
        #ifdef DEPTHSENSE_DOC
        @property bool disableAutoConfiguration;
        #endif
        /// Gets the value of the Context::disableAutoConfiguration property
        ///
        /// Gets the value of the Context::disableAutoConfiguration property.
        ///
        /// Specifies whether to disable the auto-configuration of all the
        /// depth nodes. Note that this call must be issued before any device is enumerated.
        /// Setting this property to true can prevent DepthSenseSDK to safely retrieve some information
        /// from the device (typically the controller FW version).
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or at least one device has already been enumerated.
        ///
        /// \return the value of the Context::disableAutoConfiguration property
        ///
        /// \sa setDisableAutoConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDisableAutoConfiguration ();
        /// Sets the value of the Context::disableAutoConfiguration property
        ///
        /// Sets the value of the Context::disableAutoConfiguration property.
        ///
        /// Specifies whether to disable the auto-configuration of all the
        /// depth nodes. Note that this call must be issued before any device is enumerated.
        /// Setting this property to true can prevent DepthSenseSDK to safely retrieve some information
        /// from the device (typically the controller FW version).
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or at least one device has already been enumerated.
        ///
        /// \param value the value to set
        ///
        /// \sa getDisableAutoConfiguration(), disableAutoConfigurationIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDisableAutoConfiguration (bool value);
        /// Checks whether property Context::disableAutoConfiguration is read-only
        ///
        /// Checks whether property Context::disableAutoConfiguration is read-only.
        ///
        /// Specifies whether to disable the auto-configuration of all the
        /// depth nodes. Note that this call must be issued before any device is enumerated.
        /// Setting this property to true can prevent DepthSenseSDK to safely retrieve some information
        /// from the device (typically the controller FW version).
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or at least one device has already been enumerated.
        ///
        /// \return whether property Context::disableAutoConfiguration is read-only
        ///
        /// \sa setDisableAutoConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool disableAutoConfigurationIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        struct ClientConnectedData_p
        {
            ::DSI::String appName;
            int32_t pid;
            ::DSI::String sourceIP;
            int32_t sourcePort;
        };
        #endif
        /// \struct ClientConnectedData DepthSense.hxx
        /// Holds the DepthSense::Context::ClientConnectedEvent arguments
        ///
        /// The ClientConnectedData struct holds the DepthSense::Context::ClientConnectedEvent parameters and is passed to callbacks connected to that event.
        struct ClientConnectedData
        {
            /// the name of the client executable, or an empty string if it could not be determined
            std::string appName;
            /// the process ID of the client, or \c -1 if it could not be determined
            int32_t pid;
            /// the source IP address
            std::string sourceIP;
            /// the source IP port
            int32_t sourcePort;
        };
        /// \class ClientConnectedEvent DepthSense.hxx
        /// Event raised when a client connects
        ///   
        /// The \c clientConnected event is raised when a client connects
        /// to the DepthSense server.
        ///
        /// \param appName the name of the client executable, or an empty string if it could not be determined
        /// \param pid the process ID of the client, or \c -1 if it could not be determined
        /// \param sourceIP the source IP address
        /// \param sourcePort the source IP port
        ///
        /// \sa ClientDisconnectedEvent
        class ClientConnectedEvent : public DepthSense::Event<DepthSense::Context, ClientConnectedData_p>
        {
            private:
            ClientConnectedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, ClientConnectedData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_method))(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c clientConnected event object
        ///
        /// Returns a reference to the \c clientConnected event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c clientConnected event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::ClientConnectedEvent& clientConnectedEvent () const;
        #ifndef DEPTHSENSE_DOC
        struct ClientDisconnectedData_p
        {
            ::DSI::String appName;
            int32_t pid;
            ::DSI::String sourceIP;
            int32_t sourcePort;
        };
        #endif
        /// \struct ClientDisconnectedData DepthSense.hxx
        /// Holds the DepthSense::Context::ClientDisconnectedEvent arguments
        ///
        /// The ClientDisconnectedData struct holds the DepthSense::Context::ClientDisconnectedEvent parameters and is passed to callbacks connected to that event.
        struct ClientDisconnectedData
        {
            /// the name of the client executable, or an empty string if it could not be determined
            std::string appName;
            /// the process ID of the client, or \c -1 if it could not be determined
            int32_t pid;
            /// the source IP address
            std::string sourceIP;
            /// the source IP port
            int32_t sourcePort;
        };
        /// \class ClientDisconnectedEvent DepthSense.hxx
        /// Event raised when a client disconnects
        ///   
        /// The \c clientDisconnected event is raised when a client
        /// disconnects from the DepthSense server.
        ///
        /// \param appName the name of the client executable, or an empty string if it could not be determined
        /// \param pid the process ID of the client, or \c -1 if it could not be determined
        /// \param sourceIP the source IP address
        /// \param sourcePort the source IP port
        ///
        /// \sa ClientConnectedEvent
        class ClientDisconnectedEvent : public DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>
        {
            private:
            ClientDisconnectedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_method))(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c clientDisconnected event object
        ///
        /// Returns a reference to the \c clientDisconnected event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c clientDisconnected event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::ClientDisconnectedEvent& clientDisconnectedEvent () const;
        /// \struct DeviceAddedData DepthSense.hxx
        /// Holds the DepthSense::Context::DeviceAddedEvent arguments
        ///
        /// The DeviceAddedData struct holds the DepthSense::Context::DeviceAddedEvent parameters and is passed to callbacks connected to that event.
        struct DeviceAddedData
        {
            /// the camera device that was attached to the host
            DepthSense::Device device;
        };
        /// \class DeviceAddedEvent DepthSense.hxx
        /// Event raised when a camera device is attached to the host
        ///   
        /// The \c deviceAdded event is raised when a camera device is
        /// attached to the host.
        ///
        /// \param device the camera device that was attached to the host
        ///
        /// \sa DeviceRemovedEvent
        class DeviceAddedEvent : public DepthSense::Event<DepthSense::Context, DeviceAddedData>
        {
            private:
            DeviceAddedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, DeviceAddedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    _func(obj, data.device);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    _func(obj, data.device, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_method))(obj, data.device);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceAddedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceAddedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceAddedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceAddedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::MethodHandler<DepthSense::Context, DeviceAddedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Context, DeviceAddedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c deviceAdded event object
        ///
        /// Returns a reference to the \c deviceAdded event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c deviceAdded event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::DeviceAddedEvent& deviceAddedEvent () const;
        /// \struct DeviceRemovedData DepthSense.hxx
        /// Holds the DepthSense::Context::DeviceRemovedEvent arguments
        ///
        /// The DeviceRemovedData struct holds the DepthSense::Context::DeviceRemovedEvent parameters and is passed to callbacks connected to that event.
        struct DeviceRemovedData
        {
            /// the camera device that was detached from the host
            DepthSense::Device device;
        };
        /// \class DeviceRemovedEvent DepthSense.hxx
        /// Event raised when a camera device is detached from the host
        ///   
        /// The \c deviceAdded event is raised when a camera device is
        /// detached from the host.
        ///
        /// \param device the camera device that was detached from the host
        ///
        /// \sa DeviceAddedEvent
        class DeviceRemovedEvent : public DepthSense::Event<DepthSense::Context, DeviceRemovedData>
        {
            private:
            DeviceRemovedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, DeviceRemovedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    _func(obj, data.device);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    _func(obj, data.device, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_method))(obj, data.device);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceRemovedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceRemovedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceRemovedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceRemovedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::MethodHandler<DepthSense::Context, DeviceRemovedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Context, DeviceRemovedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c deviceRemoved event object
        ///
        /// Returns a reference to the \c deviceRemoved event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c deviceRemoved event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::DeviceRemovedEvent& deviceRemovedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Audio
    {
    };
    namespace Color
    {
    };
    namespace Depth
    {
        /// \class IMUData DepthSense.hxx
        /// A class holding the data retrieved from the IMU
        ///
        /// IMU data might not be available with all devices
        class IMUData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API IMUData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::BaseValue;
            friend class DepthSense::GPIOValue;
            friend class DepthSense::FloatParameterValue;
            friend class DepthSense::BoolParameterValue;
            friend class DepthSense::IntParameterValue;
            friend class DepthSense::RegionOfInterestValue;
            friend class DepthSense::I2CArrayValue;
            friend class DepthSense::RegisterValue;
            friend class DepthSense::SystemInfoValue;
            friend class DepthSense::SystemCalibrationValue;
            friend class DepthSense::TemperatureCorrection;
            friend class DepthSense::CyclicErrorCorrection;
            friend class DepthSense::GradientDistortionCorrection;
            friend class DepthSense::Calibration;
            friend class DepthSense::HardwareVersion;
            friend class DepthSense::SystemStateValue;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::Depth::SampleDataEx;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API IMUData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API IMUData (const IMUData& other);
            DEPTHSENSE_API IMUData& operator= (const IMUData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~IMUData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit IMUData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::IMUData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::IMUData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::IMUData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::IMUData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::IMUData type object
            ///
            /// Returns the DepthSense::Depth::IMUData type object
            ///
            /// \return the DepthSense::Depth::IMUData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// Whether the data is valid or not
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API bool isValid ();
            /// The type of IMU data
            ///
            /// The IMUData::dataType property specifies the 
            /// type of IMU data received.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::ImuDataType dataType;
            #endif
            /// Gets the value of the IMUData::dataType property
            ///
            /// Gets the value of the IMUData::dataType property.
            ///
            /// The IMUData::dataType property specifies the 
            /// type of IMU data received.
            ///
            /// \return the value of the IMUData::dataType property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::ImuDataType getDataType ();
            /// The quaternion values
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::vector< float > values;
            #endif
            private:
            DEPTHSENSE_API ::DSI::Vector< float > _p_getValues ();
            public:
            /// Gets the value of the IMUData::values property
            ///
            /// Gets the value of the IMUData::values property.
            ///
            ///
            /// \return the value of the IMUData::values property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::vector< float > getValues ()
            {
                std::vector< float > retval = _p_getValues().unmarshal();
                return retval;
            }
            /// The last error encountered by the IMU board
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t lastError;
            #endif
            /// Gets the value of the IMUData::lastError property
            ///
            /// Gets the value of the IMUData::lastError property.
            ///
            ///
            /// \return the value of the IMUData::lastError property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getLastError ();
            /// The accuracy of the IMU data
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t accuracy;
            #endif
            /// Gets the value of the IMUData::accuracy property
            ///
            /// Gets the value of the IMUData::accuracy property.
            ///
            ///
            /// \return the value of the IMUData::accuracy property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getAccuracy ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
};
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Interface >
    {
        size_t operator() (DepthSense::Interface iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Audio::SampleData >
    {
        size_t operator() (DepthSense::Audio::SampleData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::AudioNode >
    {
        size_t operator() (DepthSense::AudioNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Color::SampleData >
    {
        size_t operator() (DepthSense::Color::SampleData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::ColorNode >
    {
        size_t operator() (DepthSense::ColorNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::BaseValue >
    {
        size_t operator() (DepthSense::BaseValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::GPIOValue >
    {
        size_t operator() (DepthSense::GPIOValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::FloatParameterValue >
    {
        size_t operator() (DepthSense::FloatParameterValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::BoolParameterValue >
    {
        size_t operator() (DepthSense::BoolParameterValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::IntParameterValue >
    {
        size_t operator() (DepthSense::IntParameterValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::RegionOfInterestValue >
    {
        size_t operator() (DepthSense::RegionOfInterestValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::I2CArrayValue >
    {
        size_t operator() (DepthSense::I2CArrayValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::RegisterValue >
    {
        size_t operator() (DepthSense::RegisterValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::SystemInfoValue >
    {
        size_t operator() (DepthSense::SystemInfoValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::SystemCalibrationValue >
    {
        size_t operator() (DepthSense::SystemCalibrationValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::TemperatureCorrection >
    {
        size_t operator() (DepthSense::TemperatureCorrection iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::CyclicErrorCorrection >
    {
        size_t operator() (DepthSense::CyclicErrorCorrection iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::GradientDistortionCorrection >
    {
        size_t operator() (DepthSense::GradientDistortionCorrection iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Calibration >
    {
        size_t operator() (DepthSense::Calibration iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::HardwareVersion >
    {
        size_t operator() (DepthSense::HardwareVersion iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::SystemStateValue >
    {
        size_t operator() (DepthSense::SystemStateValue iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::IMUData >
    {
        size_t operator() (DepthSense::Depth::IMUData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::SampleData >
    {
        size_t operator() (DepthSense::Depth::SampleData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::ButtonEventData >
    {
        size_t operator() (DepthSense::Depth::ButtonEventData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::SampleDataEx >
    {
        size_t operator() (DepthSense::Depth::SampleDataEx iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::DepthNode >
    {
        size_t operator() (DepthSense::DepthNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::UnsupportedNode >
    {
        size_t operator() (DepthSense::UnsupportedNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Context >
    {
        size_t operator() (DepthSense::Context iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Device >
    {
        size_t operator() (DepthSense::Device iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Node >
    {
        size_t operator() (DepthSense::Node iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< uint8_t > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< uint8_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Audio::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Audio::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< uint64_t > >
    {
        size_t operator() (DepthSense::Property< uint64_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< int32_t > >
    {
        size_t operator() (DepthSense::Property< int32_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::AudioNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::AudioNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::AudioNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::AudioNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< float > >
    {
        size_t operator() (DepthSense::Property< float > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< bool > >
    {
        size_t operator() (DepthSense::Property< bool > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Color::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Color::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ColorNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ColorNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::ColorNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::ColorNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ExposureAuto > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ExposureAuto > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::BaseValueType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::BaseValueType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< uint32_t > >
    {
        size_t operator() (DepthSense::Property< uint32_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ParameterType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ParameterType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::AccessMode > >
    {
        size_t operator() (DepthSense::Property< DepthSense::AccessMode > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::UnitType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::UnitType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::RegionOfInterest > >
    {
        size_t operator() (DepthSense::Property< DepthSense::RegionOfInterest > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< uint8_t > > >
    {
        size_t operator() (DepthSense::Property< std::vector< uint8_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::string > >
    {
        size_t operator() (DepthSense::Property< std::string > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::LensType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::LensType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::DepthSensorType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::DepthSensorType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::IlluminationType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::IlluminationType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::IntrinsicParameters > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::IntrinsicParameters > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ExtrinsicParameters > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ExtrinsicParameters > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::TemperatureCorrectionAlgorithm > >
    {
        size_t operator() (DepthSense::Property< DepthSense::TemperatureCorrectionAlgorithm > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< float > > >
    {
        size_t operator() (DepthSense::Property< std::vector< float > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::CyclicErrorCorrectionAlgorithm > >
    {
        size_t operator() (DepthSense::Property< DepthSense::CyclicErrorCorrectionAlgorithm > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::GradientDistortionCorrectionAlgorithm > >
    {
        size_t operator() (DepthSense::Property< DepthSense::GradientDistortionCorrectionAlgorithm > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< int16_t > >
    {
        size_t operator() (DepthSense::Property< int16_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::TemperatureCorrection > >
    {
        size_t operator() (DepthSense::Property< DepthSense::TemperatureCorrection > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::CyclicErrorCorrection > >
    {
        size_t operator() (DepthSense::Property< DepthSense::CyclicErrorCorrection > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::GradientDistortionCorrection > >
    {
        size_t operator() (DepthSense::Property< DepthSense::GradientDistortionCorrection > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::HardwareVersion > >
    {
        size_t operator() (DepthSense::Property< DepthSense::HardwareVersion > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ModuleId > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ModuleId > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::ImuDataType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::ImuDataType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< int16_t > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< int16_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< float > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< float > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< DepthSense::Vertex > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< DepthSense::Vertex > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< DepthSense::FPVertex > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< DepthSense::FPVertex > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< DepthSense::UV > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< DepthSense::UV > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::Acceleration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::Acceleration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::StereoCameraParameters > >
    {
        size_t operator() (DepthSense::Property< DepthSense::StereoCameraParameters > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::IMUData > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::IMUData > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< uint32_t > > >
    {
        size_t operator() (DepthSense::Property< std::vector< uint32_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::CoordinateSystemType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::CoordinateSystemType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::ButtonID > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::ButtonID > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< uint16_t > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< uint16_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::SensorValue > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::SensorValue > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::DepthNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::DepthNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::DepthNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::DepthNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< std::string > > >
    {
        size_t operator() (DepthSense::Property< std::vector< std::string > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::FrameFormat > >
    {
        size_t operator() (DepthSense::Property< DepthSense::FrameFormat > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::SystemStateValue > >
    {
        size_t operator() (DepthSense::Property< DepthSense::SystemStateValue > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::SystemCalibrationValue > >
    {
        size_t operator() (DepthSense::Property< DepthSense::SystemCalibrationValue > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::SystemInfoValue > >
    {
        size_t operator() (DepthSense::Property< DepthSense::SystemInfoValue > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Calibration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Calibration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::RawOutputMode > >
    {
        size_t operator() (DepthSense::Property< DepthSense::RawOutputMode > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::Node > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::Node > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::Device > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::Device > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Device::Model > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Device::Model > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Device::Capabilities > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Device::Capabilities > property) const;
    };
}
#endif
#endif // _DEPTHSENSE_PUBLIC_HXX
